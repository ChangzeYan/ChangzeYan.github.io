{"meta":{"title":"YCZ","subtitle":"走向内心，寻求超越","description":"天空中没有留下翅膀的痕迹，但我已飞过","author":"ChangzeYan","url":"https://changzeyan.github.io","root":"/"},"pages":[{"title":"about","date":"2019-06-13T06:56:14.000Z","updated":"2020-11-10T05:24:57.460Z","comments":true,"path":"about/index.html","permalink":"https://changzeyan.github.io/about/index.html","excerpt":"","text":""},{"title":"","date":"2020-12-02T07:57:51.294Z","updated":"2020-11-10T05:24:57.492Z","comments":true,"path":"pic/chapter1.html","permalink":"https://changzeyan.github.io/pic/chapter1.html","excerpt":"","text":"计算机组成原理第一章地址总线32根地址总线，一共可以表示$$2^32$$个地址，地址以字节为单位，所以$$2^32$$个地址一共$$2^32B=2^22K=2^12M=4G$$"},{"title":"categories","date":"2019-06-13T06:46:37.000Z","updated":"2020-11-10T05:24:57.488Z","comments":true,"path":"categories/index.html","permalink":"https://changzeyan.github.io/categories/index.html","excerpt":"","text":""},{"title":"tags","date":"2019-06-13T06:54:42.000Z","updated":"2020-11-10T05:24:57.494Z","comments":true,"path":"tags/index.html","permalink":"https://changzeyan.github.io/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"jsp-basic","slug":"Java/Jsp/jsp-basic","date":"2022-01-16T02:00:51.000Z","updated":"2022-02-16T18:54:00.722Z","comments":true,"path":"2022/01/16/java/jsp/jsp-basic/","link":"","permalink":"https://changzeyan.github.io/2022/01/16/java/jsp/jsp-basic/","excerpt":"","text":"Jsp引入bootstrap样式参考：https://blog.csdn.net/qq_43254488/article/details/85099244 下载：https://www.bootcss.com/ 点某个版本中文文档：https://v3.bootcss.com/进入下载页 下载用于生产环境的bootstrap 将下载的压缩包解压，在jsp项目webapp目录下新建static文件夹，将解压的文件夹放到static目录下： 在jsp页面中引用：方式1：用basepath &lt;%@ page language=&quot;java&quot; contentType=&quot;text/html; charset=UTF-8&quot; pageEncoding=&quot;UTF-8&quot; %&gt; &lt;% String path=request.getContextPath(); String bathPath=request.getScheme()+&quot;://&quot;+request.getServerName()+&quot;:&quot;+request.getServerPort()+path+&quot;/&quot;; %&gt; &lt;link rel=&quot;stylesheet&quot; type=&quot;text/css&quot; href=&quot;&lt;%=bathPath%&gt;/static/bootstrap-3.4.1-dist/css/bootstrap.min.css&quot;&gt; &lt;script type=&quot;text/javascript&quot; src=&quot;&lt;%=bathPath%&gt;/static/bootstrap-3.4.1-dist/js/bootstrap.min.js&quot;&gt;&lt;/script&gt; 方式2：直接引用head: &lt;link rel=&quot;stylesheet&quot; type=&quot;text/css&quot; href=&quot;static/bootstrap-3.4.1-dist/css/bootstrap.min.css&quot;&gt; &lt;script type=&quot;text/javascript&quot; src=&quot;static/bootstrap-3.4.1-dist/js/bootstrap.min.js&quot;&gt;&lt;/script&gt; body: &lt;nav aria-label=&quot;Page navigation&quot;&gt; &lt;ul class=&quot;pagination&quot;&gt; &lt;li&gt; &lt;a href=&quot;#&quot; aria-label=&quot;Previous&quot;&gt; &lt;span aria-hidden=&quot;true&quot;&gt;&amp;laquo;&lt;/span&gt; &lt;/a&gt; &lt;/li&gt; &lt;li&gt;&lt;a href=&quot;#&quot;&gt;1&lt;/a&gt; &lt;/li&gt; &lt;li&gt;&lt;a href=&quot;#&quot;&gt;2&lt;/a&gt; &lt;/li&gt; &lt;li&gt;&lt;a href=&quot;#&quot;&gt;3&lt;/a&gt; &lt;/li&gt; &lt;li&gt;&lt;a href=&quot;#&quot;&gt;4&lt;/a&gt; &lt;/li&gt; &lt;/ul&gt; &lt;/nav&gt; &lt;button type=&quot;button&quot; class=&quot;btn btn-default&quot;&gt;默认样式&lt;/button&gt; &lt;button type=&quot;button&quot; class=&quot;btn btn-primary&quot;&gt;首选项&lt;/button&gt; &lt;button type=&quot;button&quot; class=&quot;btn btn-success&quot;&gt;成功&lt;/button&gt; 添加json依赖引入以下jar包：commons-lang-2.5.jarcommons-collections-3.1.jarcommons-beanutils-1.7.0.jarjson-lib-2.4-jdk15.jarezmorph-1.0.3.jarcommons-logging-1.1.1.jar 在tomcat 的lib目录下也要放置 Bootstrap开关按钮bootstrap4-toggle：https://gitbrent.github.io/bootstrap4-toggle/","categories":[{"name":"Jsp","slug":"Jsp","permalink":"https://changzeyan.github.io/categories/Jsp/"}],"tags":[],"author":"ChangzeYan"},{"title":"tomcat","slug":"Java/tomcat/tomcat","date":"2022-01-12T10:03:57.000Z","updated":"2022-01-12T10:43:37.152Z","comments":true,"path":"2022/01/12/java/tomcat/tomcat/","link":"","permalink":"https://changzeyan.github.io/2022/01/12/java/tomcat/tomcat/","excerpt":"","text":"安装下载地址：https://tomcat.apache.org/download-80.cgi下载core版本，64-bit Windows zip (pgp, sha512) 解压后新建环境变量CATALINA_BASE ，值为根目录：D:\\Environment\\Tomcat\\apache-tomcat-8.5.59 CATALINA_HOME ，值为根目录：D:\\Environment\\Tomcat\\apache-tomcat-8.5.59 打开path，在后面添加：;%CATALINA_HOME%\\lib;%CATALINA_HOME%\\bin; 验证：cmd中输入：startup 乱码1、找到apache-tomcat-7.0.92/conf/logging.properties2、将java.util.logging.ConsoleHandler.encoding 从utf-8改为GBK 重启","categories":[{"name":"tomcat","slug":"tomcat","permalink":"https://changzeyan.github.io/categories/tomcat/"}],"tags":[],"author":"ChangzeYan"},{"title":"springboot","slug":"Java/springboot/springboot","date":"2021-12-16T12:48:22.000Z","updated":"2021-12-16T12:56:12.104Z","comments":true,"path":"2021/12/16/java/springboot/springboot/","link":"","permalink":"https://changzeyan.github.io/2021/12/16/java/springboot/springboot/","excerpt":"","text":"注解controller@Controller：用于定义控制器类，在spring项目中由控制器负责将用户发来的URL请求转发到对应的服务接口（service层），一般这个注解在类中，通常方法需要配合注解@RequestMapping。 @Controller public class Configurecontroller &#123; &#125; @RestController：用于标注控制层组件(如struts中的action)，@ResponseBody和@Controller的合集。@RequestMapping：提供路由信息，负责URL到Controller中的具体函数的映射。","categories":[],"tags":[],"author":"ChangzeYan"},{"title":"媒体视频作品集合","slug":"文史哲/HCworkshow","date":"2021-11-19T20:41:44.000Z","updated":"2021-11-19T20:45:37.593Z","comments":true,"path":"2021/11/20/wen-shi-zhe/hcworkshow/","link":"","permalink":"https://changzeyan.github.io/2021/11/20/wen-shi-zhe/hcworkshow/","excerpt":"","text":"笑着打开这个视频，看完发现眼里进了沙16.0万播放 · 总弹幕数563 谁是自然界的节奏大师158.0万播放 · 总弹幕数865","categories":[],"tags":[],"author":"ChangzeYan"},{"title":"杂文","slug":"文史哲/poetry","date":"2021-10-21T12:22:58.000Z","updated":"2022-02-16T20:14:55.136Z","comments":true,"path":"2021/10/21/wen-shi-zhe/poetry/","link":"","permalink":"https://changzeyan.github.io/2021/10/21/wen-shi-zhe/poetry/","excerpt":"","text":"思 幽幽出皓月，浅浅入白雪。 微微携清风，渐渐眠江夜。 回来再次走过那几条路，恍若隔世。 2021年10月25日，晴。偶然间发现自己一直被上天眷顾，高中一直念叨以后一定要来北京，虽然当时没能如愿，但兜兜转转几年后我竟真的来了北京，与其说是来到，更有一种回到的感觉，尽管这感觉并不真实可信，或者是一种错觉。错到我认为北京就像一个吸铁石，我是一个漂浮的铁屑，一个铁屑是无法决定它要去哪的，它只能被吸铁石吸走。但是到了北京并没有我想象地那么欣喜，反而心静地像是没有风的湖面，没有一丝波澜。也许是人生早已有了剧本，我只需要按照它走下去就好了。但是这剧本没人给我剧透，我不知何时来，也不知何时去。但我知道无论怎么走都超不出它的范围，所以我每次走在十字路口不知道往哪走的时候，我总是告诉自己随便选一个，或者取局部最优解就可以。我这样做是因为我相信我的结局已经写好了，条条大路通罗马，只要大方向没错，我怎么走都能到达终点，无非是走的进还是走得远，走得轻松还是走得辛苦。最近我说会成为一个符号，隔天就变成了“Y”，我觉得很巧，蹊跷，甚至很离谱。导致我一度怀疑是有一根看不见的线将世间你我相连，被连起来的人有着莫名其妙相通的情愫。但是谁跟谁连在一起、连多长时间只有负责连线的人才知道，自己是不知道自己身上有没有线，有几根线，线的那头是谁的。如果只到这里还情有可原，但是昨天发现网易云音乐中有一首名为“Y”的歌，（2021.11.03 5:53）我记住这首歌第一是因为一个人，第二是因为下面的两条评论。总之已经忘了歌词忘了旋律。第一条评论的大意是“Y”就像一个岔路口，两个人起点不同，但最终还是走在一起。第二条评论大意是本来走在一起的两个人走着走着就分开了。我比较赞成第一种解释，因为写“Y”是从上向下写的，没人会倒立着写它。 我总觉得每个人来到这里是为了一件事的，虽然他自己也不知道是什么事，也许是看看花，也许是走一段路，又或许是见一个人。当事情做完后他就走了，有的人不舍是因为他不知道自己已经做完了，有的人想提前走是因为他觉得自己不想再做了。 黑客帝国昨天看了b站青蛙刀圣的黑客帝国解析，觉得自己好像明白了什么，又好像什么都没明白。给我印象最深的看点有三个，第一个是宿命论、决定论以及个人意志在人的一生中的作用；第二个是看到自身时刻处于矩阵之中但不知道是否要打破矩阵及其意义以及怎么打破矩阵；第三个是选择，究竟有没有选择，选择是偶然还是毕然。 我并不是从一开始就相信宿命论，在最早的时候，我其实一直相信个人意志的作用是占主导地位的，也许这跟我从小受到的家庭教育有关。当时的我非常看重努力的作用，相信类似“努力总有收获”的话，这在一定程度上没有错，反而有益，我在不是特别迷恋这句话的时候其实是这种思想的受益者。但是，当过分认同个人意志时，有可能会带来毁灭。因为如果过分相信个人意志和个人努力，忽略了其他可能对结果造成影响的因素，当结果不如预期，便会造成心理落差，从而开始怀疑自己、否定自己。如果没有得到适当引导，及时从中走出的话，便会造成心理崩溃。事实上，我曾经徘徊在这一危险境地的边缘或是已经深陷泥潭。好在最后逐渐认识到个人意志只是影响结果的其中一个因素。如果将导致结果的各个因素看作一个网络，因素则可以看作其中的节点，每个节点都有相应的权重，每个人都有自己的网络，网络中各项节点的权重也因人而异。有的人可能看重个人意志，则表现出努力、奋斗的特质（当然表现努力这一结果也受多个条件影响，比如目标、人生规划、环境等，所以人最终的结果是一个网络导致的）；有的人可能不是特别看重，则表现为随遇而安。其程度是由变量前面的系数决定的， 导致我观念转变的另一因素是一方面是感受到个人意志对结果影响越来越小，不期而遇对结果带来的影响越来越大。比如找工作一开始是在互联网投入了巨大精力，但是结果却不如预期（当然也与我准备不足等因素有关），而在体制工作上并没有投入很多精力却带来了意外惊喜。所以我想我现在选择这个工作究竟是已经注定的还是前期找互联网不顺进而对其疲惫于是转而寻找其他出路这一原因导致的。如果一开始我找互联网很顺利那么后面还会不会有如今这一选择。 不仅是工作上还有爱情上，当我想找对象时，尝试相亲，可以看作是通过发挥个人意志的作用，来影响状态这一结果，结果失败了，但靠缘分这种虚无缥缈的东西却成功了。当然这其中还有其他因素，但这些因素肯定是原因，是这些原因导致的最终结果。 分析到这里，我现在能得出的结论是我是相信因果决定论的。因此相信没有什么选择，选择结果是确定的，要做的只是理解为什么选择。","categories":[{"name":"文史哲","slug":"文史哲","permalink":"https://changzeyan.github.io/categories/%E6%96%87%E5%8F%B2%E5%93%B2/"}],"tags":[],"author":"ChangzeYan"},{"title":"Excel","slug":"write/Excel/excel","date":"2021-09-16T10:58:22.000Z","updated":"2021-11-19T20:29:06.411Z","comments":true,"path":"2021/09/16/write/excel/excel/","link":"","permalink":"https://changzeyan.github.io/2021/09/16/write/excel/excel/","excerpt":"","text":"函数求和函数两行对应的数值相乘求和：B2列到AB2列这一行与B3:AB3列这一行对应相乘求和 =SUMPRODUCT($B$2:$AB$2, B3:AB3)","categories":[{"name":"Excel","slug":"Excel","permalink":"https://changzeyan.github.io/categories/Excel/"}],"tags":[],"author":"ChangzeYan"},{"title":"webdriverer命令","slug":"Python/webdriver/webdriverer-basic","date":"2021-09-03T03:43:31.000Z","updated":"2021-11-19T20:31:54.668Z","comments":true,"path":"2021/09/03/python/webdriver/webdriverer-basic/","link":"","permalink":"https://changzeyan.github.io/2021/09/03/python/webdriver/webdriverer-basic/","excerpt":"","text":"Webdriver使用安装 pip install selenium 下载与浏览器版本对应的驱动：chrome：http://npm.taobao.org/mirrors/chromedriver/http://chromedriver.storage.googleapis.com/index.html下载后放到以下目录：C:\\Program Files (x86)\\Google\\Chrome\\Application然后修改环境变量，在path后面加：;C:\\Program Files (x86)\\Google\\Chrome\\Application导包 from selenium import webdriver from selenium.webdriver import ChromeOptions 启动与打开网页： 本地: option = ChromeOptions() # 启动chrome时，去掉window.navigator.webdriver属性，使浏览器检测不到webdriver option.add_experimental_option(&#39;excludeSwitches&#39;, [&#39;enable-automation&#39;]) browser = webdriver.Chrome(options=option) browser.get(r&quot;C:\\Users\\Changze\\Desktop\\gongzhong.html&quot;) 拖动滚动条 # 拖动十次 for i in range(10): browser.execute_script(&quot;window.scrollTo(0, document.body.scrollHeight);&quot;) # 两次拖动之间间隔随机时间 time.sleep(random.randint(2, 5)) 获取标签的属性值： &lt;time datetime=&quot;2021-07-01T09:17:23.000Z&quot;&gt;7月1日&lt;/time&gt; ele_time = twitter.find_element_by_tag_name(&#39;time&#39;) datetime = ele_time.get_attribute(&#39;datetime&#39;)","categories":[{"name":"Webdriver","slug":"Webdriver","permalink":"https://changzeyan.github.io/categories/Webdriver/"}],"tags":[],"author":"ChangzeYan"},{"title":"PS快捷键","slug":"PhotoShop/PS快捷键","date":"2021-08-30T08:16:45.000Z","updated":"2021-11-19T20:33:03.307Z","comments":true,"path":"2021/08/30/photoshop/ps-kuai-jie-jian/","link":"","permalink":"https://changzeyan.github.io/2021/08/30/photoshop/ps-kuai-jie-jian/","excerpt":"","text":"PS 快捷键缩放图片中的某一部分：ctrl+t鼠标放在边框上拖拉缩放 路径变选区：ctrl+enter 填充前景色到图层或选区：Alt + Backspace或Delete 填充背景色到图层或选区：Ctrl + Backspace或Delete 复制图层：ctrl+j 取消选区：Ctrl+D 扣字变换颜色选择主体后，用魔棒圈出字体轮廓，ctrl+enter载入选区，然后alt+del填充前景色参考：怎么用PS改变图片中部分区域的颜色？ 删除背景色魔棒工具选中背景色，然后del健删除","categories":[{"name":"PS","slug":"PS","permalink":"https://changzeyan.github.io/categories/PS/"}],"tags":[],"author":"ChangzeYan"},{"title":"中国古代土地制度演变及所有权归属","slug":"文史哲/中国古代土地制度演变及所有权归属","date":"2021-08-19T07:33:40.000Z","updated":"2021-11-19T20:25:36.837Z","comments":true,"path":"2021/08/19/wen-shi-zhe/zhong-guo-gu-dai-tu-di-zhi-du-yan-bian-ji-suo-you-quan-gui-shu/","link":"","permalink":"https://changzeyan.github.io/2021/08/19/wen-shi-zhe/zhong-guo-gu-dai-tu-di-zhi-du-yan-bian-ji-suo-you-quan-gui-shu/","excerpt":"","text":"原文：https://baijiahao.baidu.com/s?id=1600769382305099561&amp;wfr=spider&amp;for=pc参考：https://zhuanlan.zhihu.com/p/63156984 先秦夏、商时期，土地制度是以氏族为单位的土地公有制，农业生产往往采取集体劳作的方式进行。 武王克商以后，采用“分封亲戚、以藩屏周”的政策，把他的同姓宗亲和功臣谋士分封各地，建立诸侯国。分封地的主权和产权是周王的，诸侯只有财权和治权。全国的土地与臣民，名义上都属周王所有，正如《诗·小雅·北山》所说：“普天之下，莫非王土；率土之滨，莫非王臣”。当时的土地制度为井田制。井田制规定一切土地属于国家所有（即属于周天子所有），周王是全国最高的统治者，也是最高的土地所有者。 其特点有三：一是土地国有，亦即归周天子所有；二是分赐诸侯臣下，世代享用，不得买卖；三是缴纳贡赋。诸侯大夫对分封的土地只享有使用权而无所有权，并且要按时向周天子缴纳贡赋。 井田制是把耕地划分为多块一定面积的方田，周围有经界，中间有水沟，阡陌纵横，像一个井字。一人耕种大约100亩（约合今70公亩）。100亩为一个方块，称为“一田”。甲骨文中的“田”字也是由此而来。 一井分为9个方块，周围的8块田由8户耕种，谓之私田，私田收成全部归耕户所有；中间是公田，由8户共耕，收入全归封邑贵族所有。 建国后我国土地所有权，分为国家土地所有权和集体土地所有权，自然人不能成为土地所有权的主体。中华人民共和国是国家土地所有权的统一和唯一的主体，由其代表全体人民对国有土地享有独占性支配的权利。","categories":[{"name":"文史哲","slug":"文史哲","permalink":"https://changzeyan.github.io/categories/%E6%96%87%E5%8F%B2%E5%93%B2/"}],"tags":[],"author":"ChangzeYan"},{"title":"修改图片大小","slug":"PhotoShop/修改图片大小","date":"2021-07-18T05:11:48.000Z","updated":"2021-11-19T20:34:11.908Z","comments":true,"path":"2021/07/18/photoshop/xiu-gai-tu-pian-da-xiao/","link":"","permalink":"https://changzeyan.github.io/2021/07/18/photoshop/xiu-gai-tu-pian-da-xiao/","excerpt":"","text":"修改分辨率大小参考：ps2021怎么修改图片尺寸? ps2021调整图片大小的三种方法 工作视图选择图形和web 修改像素值 修改内存大小参考：用ps怎么缩小图片大小保持图片的清晰度? 选择，文件，导出，存储为web和设备所用格式（旧版） 在预设中选择品质，左下角显示修改后的图片内存大小","categories":[{"name":"PS","slug":"PS","permalink":"https://changzeyan.github.io/categories/PS/"}],"tags":[],"author":"ChangzeYan"},{"title":"修改证件照背景","slug":"PhotoShop/修改证件照背景","date":"2021-07-14T02:47:19.000Z","updated":"2021-09-02T07:18:07.607Z","comments":true,"path":"2021/07/14/photoshop/xiu-gai-zheng-jian-zhao-bei-jing/","link":"","permalink":"https://changzeyan.github.io/2021/07/14/photoshop/xiu-gai-zheng-jian-zhao-bei-jing/","excerpt":"","text":"参考： ps2020超快速更换证件照背景颜色的 PS2021的对象选择工具可真是太秀了！ 版本ps2021 方法一 使用对象选择工具 框住人物 点击遮住并覆盖 在输出颜色中选中净化颜色，确定 （抠图） 新建图层 ，右下角加号 设置新图层背景色，这里修改为白色 ctrl+delete 删除人像 将人像图层拖动到背景图层前 这样背景就换成白色了，如果想换成红色： 新建图层，设置图层背景色为红色，#FF0000 ，然后ctrl+delete删除人像 将人物图层拖动到背景前 方法二 ctrl+f，在快速操作中选择移除背景。 然后新建图层，设置背景色（ctrl+backspace填充背景色） 将人物图层移动到背景图层之上 方法三 右下角选择色相/饱和度，右下角 点击手形按钮，然后点击背景色，滑动调整色相、饱和度等","categories":[{"name":"PS","slug":"PS","permalink":"https://changzeyan.github.io/categories/PS/"}],"tags":[],"author":"ChangzeYan"},{"title":"PPT","slug":"write/PPT/PPT","date":"2021-06-18T11:56:49.000Z","updated":"2021-06-18T12:13:06.311Z","comments":true,"path":"2021/06/18/write/ppt/ppt/","link":"","permalink":"https://changzeyan.github.io/2021/06/18/write/ppt/ppt/","excerpt":"","text":"设置主题字体设计中右边框点击小三角 自定义添加字体：","categories":[],"tags":[],"author":"ChangzeYan"},{"title":"jmeter","slug":"SoftwareTest/jmeter","date":"2021-06-05T12:03:46.000Z","updated":"2021-06-05T12:59:14.586Z","comments":true,"path":"2021/06/05/softwaretest/jmeter/","link":"","permalink":"https://changzeyan.github.io/2021/06/05/softwaretest/jmeter/","excerpt":"","text":"Jmeter参考：JMeter性能测试，完整入门篇 安装下载地址 执行：解压后，执行bin下面的jmeter.bat即可 安装jp@gc等插件参考：Jmeter-监听器jp@gc 使用监听器jp@gc的，需要选项中存在Plugins Manager,如果没有请下插件：Plugins Manager 下载后放置在jmeter安装目录下的lib/ext中，重新启动即可 如下图，安装jpgc插件： 生成web页面的报告jmeter -n -t D:\\program\\apache-jmeter-5.0\\samples\\28.summary_report.jmx -l d:\\summary.jtl -e -o d:\\result jmx文件：jmeter的测试项目文件jtl文件：生成的脚本文件d:\\result：web页面报告的存储路径（必须为空目录）","categories":[{"name":"SoftwareTest","slug":"SoftwareTest","permalink":"https://changzeyan.github.io/categories/SoftwareTest/"}],"tags":[],"author":"ChangzeYan"},{"title":"Latex-参考文献","slug":"write/Latex/Latex-参考文献","date":"2021-05-09T11:22:34.000Z","updated":"2021-07-01T11:25:05.498Z","comments":true,"path":"2021/05/09/write/latex/latex-can-kao-wen-xian/","link":"","permalink":"https://changzeyan.github.io/2021/05/09/write/latex/latex-can-kao-wen-xian/","excerpt":"","text":"vscode 编译bib文件的配置参考：vscode latex 踩坑记 ： 文献索引 bib 文件和setting.json的那点事 在vscode中 file-&gt;preferences-&gt;settings： 点击右上角的（open settings(Json)）: 复制下面代码： &#123; &quot;latex-workshop.latex.recipes&quot;: [ &#123; &quot;name&quot;: &quot;xelatex -&gt; bibtex -&gt; xelatex*2&quot;, &quot;tools&quot;: [ &quot;xelatex&quot;, &quot;bibtex&quot;, &quot;xelatex&quot;, &quot;xelatex&quot; ] &#125;, &#123; &quot;name&quot;: &quot;XeLaTeX&quot;, &quot;tools&quot;: [ &quot;xelatex&quot; ] &#125;, &#123; &quot;name&quot;: &quot;LaTeXmk&quot;, &quot;tools&quot;: [ &quot;latexmk&quot; ] &#125;, // &#123; // &quot;name&quot;: &quot;PDFLaTeX&quot;, // &quot;tools&quot;: [ // &quot;pdflatex&quot; // ] // &#125;, &#123; &quot;name&quot;: &quot;BibTeX&quot;, &quot;tools&quot;: [ &quot;bibtex&quot; ] &#125;, // &#123; // &quot;name&quot;: &quot;pdflatex -&gt; bibtex -&gt; pdflatex*2&quot;, // &quot;tools&quot;: [ // &quot;pdflatex&quot;, // &quot;bibtex&quot;, // &quot;pdflatex&quot;, // &quot;pdflatex&quot; // ] // &#125; ], &quot;latex-workshop.latex.tools&quot;: [ &#123; &quot;name&quot;: &quot;xelatex&quot;, &quot;command&quot;: &quot;xelatex&quot;, &quot;args&quot;: [ &quot;-synctex=1&quot;, &quot;-interaction=nonstopmode&quot;, &quot;-file-line-error&quot;, &quot;%DOCFILE%&quot; ] &#125;, &#123; &quot;name&quot;: &quot;pdflatex&quot;, &quot;command&quot;: &quot;pdflatex&quot;, &quot;args&quot;: [ &quot;-synctex=1&quot;, &quot;-interaction=nonstopmode&quot;, &quot;-file-line-error&quot;, &quot;%DOCFILE%&quot; ] &#125;, &#123; &quot;name&quot;: &quot;latexmk&quot;, &quot;command&quot;: &quot;latexmk&quot;, &quot;args&quot;: [ &quot;-synctex=1&quot;, &quot;-interaction=nonstopmode&quot;, &quot;-file-line-error&quot;, &quot;-pdf&quot;, &quot;-outdir=%OUTDIR%&quot;, &quot;%DOCFILE%&quot; ] &#125;, &#123; &quot;name&quot;: &quot;bibtex&quot;, &quot;command&quot;: &quot;bibtex&quot;, &quot;args&quot;: [ &quot;%DOCFILE%&quot; ] &#125; ], &quot;latex-workshop.latex.clean.fileTypes&quot;: [ &quot;*.aux&quot;, &quot;*.bbl&quot;, &quot;*.blg&quot;, &quot;*.idx&quot;, &quot;*.ind&quot;, &quot;*.lof&quot;, &quot;*.lot&quot;, &quot;*.out&quot;, &quot;*.toc&quot;, &quot;*.acn&quot;, &quot;*.acr&quot;, &quot;*.alg&quot;, &quot;*.glg&quot;, &quot;*.glo&quot;, &quot;*.gls&quot;, &quot;*.ist&quot;, &quot;*.fls&quot;, &quot;*.log&quot;, &quot;*.fdb_latexmk&quot; ], &quot;files.autoSave&quot;: &quot;afterDelay&quot;, &quot;editor.wordWrap&quot;: &quot;on&quot;, &quot;explorer.confirmDelete&quot;: false, &quot;git.autofetch&quot;: true, &quot;window.zoomLevel&quot;: 0, &quot;explorer.confirmDragAndDrop&quot;: false, &#125; 配置文件注意点原来我的配置是下面这样（也是很多博客中的做法）： &quot;latex-workshop.latex.recipes&quot;: [ &#123; &quot;name&quot;: &quot;xelatex&quot;, &quot;tools&quot;: [ &quot;xelatex&quot; ] &#125;, &#123; &quot;name&quot;: &quot;latexmk&quot;, &quot;tools&quot;: [ &quot;latexmk&quot; ] &#125;, &#123; &quot;name&quot;: &quot;pdflatex -&gt; bibtex -&gt; pdflatex*2&quot;, &quot;tools&quot;: [ &quot;pdflatex&quot;, &quot;bibtex&quot;, &quot;pdflatex&quot;, &quot;pdflatex&quot; ] &#125; ], 这个配置的问题在于，只会使用第一个recipe &#123; &quot;name&quot;: &quot;xelatex&quot;, &quot;tools&quot;: [ &quot;xelatex&quot; ] &#125;, 会导致只编译一次，而bib文件不会被编译，导致参考文献出不来 而用命令行编译是四次，结果正常： xelatex -shell-escape thesis.tex bibtex thesis xelatex -shell-escape thesis.tex xelatex -shell-escape thesis.tex 假设我们的核心文件是hello.tex，我们的参考文件是ref.bib，在hello.tex文末通过 \\bibliography{ref} 来指明引用的文件叫做ref.bib。然后编译hello.tex，发现文章除了参考文献之外的其他内容都是正常的，唯独参考文献。这是因为只用了xelatex来编译hello.tex。而ref.bib也需要编译，通过bibtex。而直接在命令行里输入bibtex ref.bib会有问题报错说找不到ref.aux。本文件夹里只有hello.aux，因此只需要将ref.bib改名为hello.bib即可（在hello.tex中也需要将对应的 \\bibliography{ref} 改为 \\bibliography{hello}），然后先编译hello.tex（这个能在vscode里通过ctrl+s自动保存hello.tex进而自动编译）生成hello.aux，再通过命令行编译hello.bib生成hello.bbl，然后再编译hello.tex更新hello.aux，然后再编译hello.tex将其与参考文献(hello.bbl)真正结合起来。所以一共需要编译4次！ 很麻烦！那么我们只需要对上述的三个recipe调换顺序即可，把第三个放到第一位置： &quot;latex-workshop.latex.recipes&quot;: [ &#123; &quot;name&quot;: &quot;pdflatex -&gt; bibtex -&gt; pdflatex*2&quot;, &quot;tools&quot;: [ &quot;pdflatex&quot;, &quot;bibtex&quot;, &quot;pdflatex&quot;, &quot;pdflatex&quot; ] &#125; &#123; &quot;name&quot;: &quot;xelatex&quot;, &quot;tools&quot;: [ &quot;xelatex&quot; ] &#125;, &#123; &quot;name&quot;: &quot;latexmk&quot;, &quot;tools&quot;: [ &quot;latexmk&quot; ] &#125;, ], 这样就可以了通过一次单纯的ctrl+s自动顺序完成全部4次编译！而且也不必保证.bib文件名必须与.tex一致。缺点是每次都会编译4次。（pdflatex可以换为xelatex或latexmk，pdflatex比xelatex快，latexmk最慢）。 反向搜索和正向搜索反向搜索 默认在pdf中ctrl+鼠标左键就能定位到源文件位置 正向搜索 在源文件中定位到pdf与之对应位置 点击这个SyncTex from cursor，pdf就能滚动到当前鼠标所在源文件对应位置： 各参考文献格式@article 期刊杂志的论文 必要域: author, title, journal, year. 可选域: volume, number, pages, month, note. @book 公开出版的图书 必要域: author/editor, title, publisher, year. 可选域: volume/number, series, address, edition, month, note. @booklet 无出版商或作者的图书 必要域: title. 可选域: author, howpublished, address, month, year, note. @conference 等价于 inproceedings 必要域: author, title, booktitle, year. 可选域: editor, volume/number, series, pages, address, month, organization, publisher, note. @inbook 书籍的一部分章节 必要域: author/editor, title, chapter and/or pages, publisher, year. 可选域: volume/number, series, type, address, edition, month, note. @incollection 书籍中带独立标题的章节 必要域: author, title, booktitle, publisher, year. 可选域: editor, volume/number, series, type, chapter, pages, address, edition, month, note. **publisher和address如果没有的话可能会有缺失[S.I.]** @inproceedings 会议论文集中的一篇 必要域: author, title, booktitle, year. 可选域: editor, volume/number, series, pages, address, month, organization, publisher, note. @manual 技术文档 必要域: title. 可选域: author, organization, address, edition, month, year, note. @mastersthesis 硕士论文 必要域: author, title, school, year. 可选域: type, address, month, note. @misc 其他 必要域: none 可选域: author, title, howpublished, month, year, note. @phdthesis 博士论文 必要域: author, title, year, school. 可选域: address, month, keywords, note. @proceedings 会议论文集 必要域: title, year. 可选域: editor, volume/number, series, address, month, organization, publisher, note. @techreport 教育，商业机构的技术报告 必要域: author, title, institution, year. 可选域: type, number, address, month, note. @unpublished 未出版的论文，图书 必要域: author, title, note. 可选域: month, year.","categories":[{"name":"Latex","slug":"Latex","permalink":"https://changzeyan.github.io/categories/Latex/"}],"tags":[],"author":"ChangzeYan"},{"title":"Pandas","slug":"Python/pandas","date":"2021-03-13T11:51:15.000Z","updated":"2021-09-13T15:09:05.354Z","comments":true,"path":"2021/03/13/python/pandas/","link":"","permalink":"https://changzeyan.github.io/2021/03/13/python/pandas/","excerpt":"","text":"DataFrame创建dataframe df = pd.DataFrame(columns=[&#39;a&#39;,&#39;b&#39;]) 给dataframe增加行： for i in range(5): df.loc[i]=[1,2,3] 排序对行排序： 按照&#39;阅读&#39;列将行降序排列 sort_res=df.sort_index(axis=0, by=&#39;阅读&#39;, ascending=False) 保存保存到excel中： df.to_excel(&#39;test.xls&#39;) 统计某列值出现的次数import pandas as pd import numpy as np df = pd.DataFrame(&amp;#123;'key1':['a','a','b','b','a'],'key2':['one','two','one','two','one'],'data1':np.random.randn(5),'data2':np.random.randn(5)&amp;#125;) 统计key2中各个元素的出现次数： df['key2'].value_counts() //返回series Series遍历seriesseries = data['author'].value_counts() for i, v in series.items(): print(i, v)","categories":[{"name":"Python","slug":"Python","permalink":"https://changzeyan.github.io/categories/Python/"}],"tags":[{"name":"pandas","slug":"pandas","permalink":"https://changzeyan.github.io/tags/pandas/"}],"author":"ChangzeYan"},{"title":"origin","slug":"write/origin/origin","date":"2021-03-13T07:53:11.000Z","updated":"2021-05-23T11:55:03.532Z","comments":true,"path":"2021/03/13/write/origin/origin/","link":"","permalink":"https://changzeyan.github.io/2021/03/13/write/origin/origin/","excerpt":"","text":"倾斜横坐标双击横坐标下的文字，或者右键选择横坐标，然后点击刻度线标签 然后接着点击刻度线标签下的格式，设置旋转角度： 根据某两列计算第三列数参考：origin 8.0两列相加怎么算 全选要生成的列，右键，set colum values。 去掉导出图片的白边右键图片，选择 Fit page to layers，根据需要调整border值。","categories":[{"name":"Origin","slug":"Origin","permalink":"https://changzeyan.github.io/categories/Origin/"}],"tags":[],"author":"ChangzeYan"},{"title":"代码和算法","slug":"write/Latex/Latex-lst","date":"2021-03-11T13:21:26.000Z","updated":"2021-05-22T02:30:18.491Z","comments":true,"path":"2021/03/11/write/latex/latex-lst/","link":"","permalink":"https://changzeyan.github.io/2021/03/11/write/latex/latex-lst/","excerpt":"","text":"定制lstlisting 的标题参考：按照算法标题样式定制listings的标题 \\renewcommand*\\thelstnumber&#123;\\arabic&#123;lstnumber&#125;:&#125; \\DeclareCaptionFormat&#123;mylst&#125;&#123;\\hrule#1#2#3&#125; \\captionsetup[lstlisting]&#123;format=mylst,labelfont=bf,singlelinecheck=off,labelsep=space&#125; \\documentclass&#123;article&#125; \\usepackage&#123;listings&#125; \\usepackage&#123;caption&#125; \\lstset&#123; language=C++, basicstyle=\\small\\ttfamily, numbers=left, numbersep=5pt, xleftmargin=20pt, showstringspaces=false, %去掉空格时产生的下划的空格标志, 设置为true则出现 frame=tb, framexleftmargin=20pt &#125; \\renewcommand*\\thelstnumber&#123;\\arabic&#123;lstnumber&#125;:&#125; \\DeclareCaptionFormat&#123;mylst&#125;&#123;\\hrule#1#2#3&#125; \\captionsetup[lstlisting]&#123;format=mylst,labelfont=bf,singlelinecheck=off,labelsep=space&#125; \\begin&#123;document&#125; \\begin&#123;lstlisting&#125;[caption=&#123;test algorithm&#125;,label=&#123;lst1&#125;] #include using namespace std; int main() &#123; cout &lt;&lt; &quot;Welcome to the wonderful world of C++!!!\\n&quot;; return 0; &#125; \\end&#123;lstlisting&#125; \\end&#123;document&#125;","categories":[{"name":"Latex","slug":"Latex","permalink":"https://changzeyan.github.io/categories/Latex/"}],"tags":[{"name":"Lst","slug":"Lst","permalink":"https://changzeyan.github.io/tags/Lst/"}],"author":"ChangzeYan"},{"title":"Keras","slug":"Python/NLP/Keras","date":"2021-03-09T11:27:36.000Z","updated":"2021-04-13T07:35:37.839Z","comments":true,"path":"2021/03/09/python/nlp/keras/","link":"","permalink":"https://changzeyan.github.io/2021/03/09/python/nlp/keras/","excerpt":"","text":"Keras 和 Tensorflow的版本对应关系tensorflow 2.0 - keras 2.2.4 tensorflow 1.9 - keras 2.2.0 对应keras-transformer==0.31.0 tensorflow 1.8 - keras 2.1.6 tensorflow 1.5 - keras 2.1.4 tensorflow 1.4 - keras 2.1.3 tensorflow 1.3 - keras 2.1.2 tensorflow 1.2 - keras 2.1.1 TensorFlow 1.14.0 + Keras 2.2.5 on Python 3.6. TensorFlow 1.13.0 + Keras 2.2.4 on Python 3.6. TensorFlow 1.12.0 + Keras 2.2.4 on Python 3.6. TensorFlow 1.11.0 + Keras 2.2.4 on Python 3.6. TensorFlow 1.10.0 + Keras 2.2.0 on Python 3.6. TensorFlow 1.12.0 + Keras 2.2.4 on Python 2. TensorFlow 1.11.0 + Keras 2.2.4 on Python 2. 保存和加载模型参考：Keras框架下的保存模型和加载模型 完整保存使用model.save()完整地保存整个模型，将Keras模型和权重保存在一个HDF5文件中，该文件将包含：模型的结构，模型的参数以及优化器参数：用于继续训练过程 from __future__ import print_function import numpy as np from keras.models import Sequential from keras.layers.core import Dense, Activation from keras.optimizers import SGD from keras.utils import np_utils #随机数种子，重复性设置 np.random.seed(1671) #网络结构和训练的参数 NB_EPOCH = 20 BATCH_SIZE = 128 VERBOSE = 1 NB_CLASSES = 10 OPTIMIZER = SGD() N_HIDDEN = 128 VALIDATION_SPLIT = 0.2 RESHAPED = 784 #加载数据 def load_data(path=\"mnist.npz\"): f = np.load(path) x_train, y_train = f['x_train'], f['y_train'] x_test, y_test = f['x_test'], f['y_test'] f.close() return (x_train, y_train), (x_test, y_test) #调用函数加载数据 (x_train, y_train), (x_test, y_test) = load_data() #数据预处理 (x_train, y_train), (x_test, y_test) = load_data() #数据变形、类型转换及归一化 x_train = x_train.reshape(60000, 784).astype('float32') / 255 x_test = x_test.reshape(10000, 784).astype('float32') / 255 #打印消息 print('Training samples:', x_train.shape) print('Testing samples:', x_test.shape) #将类别转换为one-hot编码 y_train = np_utils.to_categorical(y_train, NB_CLASSES) y_test = np_utils.to_categorical(y_test, NB_CLASSES) #定义网络结构 model = Sequential() model.add(Dense(N_HIDDEN, input_shape=(RESHAPED, ))) model.add(Activation('relu')) model.add(Dense(N_HIDDEN)) model.add(Activation('relu')) model.add(Dense(NB_CLASSES)) model.add(Activation('softmax')) #打印模型概述信息 model.summary() #编译模型 model.compile(loss='categorical_crossentropy', optimizer=OPTIMIZER, metrics=['accuracy']) #训练模型 history = model.fit(x_train, y_train, batch_size=BATCH_SIZE, epochs=NB_EPOCH, verbose=VERBOSE, validation_split=VALIDATION_SPLIT) #评估模型 score = model.evaluate(x_test, y_test, verbose=VERBOSE) print('Test score:', score[0]) print('Test accuracy:', score[1]) # 保存模型 model.save('my_model.h5') 加载： from keras.models import load_model #加载整个模型 model = load_model('my_model.h5') #训练模型 history = model.fit(x_train, y_train, batch_size=BATCH_SIZE, epochs=NB_EPOCH, verbose=VERBOSE, validation_split=VALIDATION_SPLIT) #评估模型 score = model.evaluate(x_test, y_test, verbose=VERBOSE) 保存模型结构和权重from __future__ import print_function import numpy as np from keras.models import Sequential from keras.layers.core import Dense, Activation from keras.optimizers import SGD from keras.utils import np_utils # 定义网络结构 model = Sequential() model.add(Dense(N_HIDDEN, input_shape=(RESHAPED, ))) model.add(Activation('relu')) model.add(Dense(N_HIDDEN)) model.add(Activation('relu')) model.add(Dense(NB_CLASSES)) model.add(Activation('softmax')) # 打印模型概述信息 model.summary() # 编译模型 model.compile(loss='categorical_crossentropy', optimizer=OPTIMIZER, metrics=['accuracy']) # 训练模型 history = model.fit(x_train, y_train, batch_size=BATCH_SIZE, epochs=NB_EPOCH, verbose=VERBOSE, validation_split=VALIDATION_SPLIT) # 评估模型 score = model.evaluate(x_test, y_test, verbose=VERBOSE) print('Test score:', score[0]) print('Test accuracy:', score[1]) # 保存模型的结构 json_string = model.to_json() # 方式1 open('model_architecture_1.json', 'w').write(json_string) yaml_string = model.to_yaml() # 方式2 open('model_arthitecture_2.yaml', 'w').write(yaml_string) # 保存模型的权重 model.save_weights('my_model_weights.h5') # 打印消息 print('训练和保存模型结构完成！！！') 加载结构： from keras.models import model_from_json from keras.models import model_from_yaml # 加载模型结构 model = model_from_json(open('model_architecture_1.json', 'r').read()) 或： model = model_from_yaml(open('model_arthitecture_2.yaml', 'r').read()) # 加载模型权重 model.load_weights('my_model_weights.h5')","categories":[{"name":"Python","slug":"Python","permalink":"https://changzeyan.github.io/categories/Python/"}],"tags":[{"name":"NLP","slug":"NLP","permalink":"https://changzeyan.github.io/tags/NLP/"}],"author":"ChangzeYan"},{"title":"Pip","slug":"Python/Python语法/pip","date":"2021-02-10T02:32:04.000Z","updated":"2021-02-10T02:57:33.448Z","comments":true,"path":"2021/02/10/python/python-yu-fa/pip/","link":"","permalink":"https://changzeyan.github.io/2021/02/10/python/python-yu-fa/pip/","excerpt":"","text":"查看pip 安装了那些包查看所有 pip list 查看是否安装了某个包 centos pip list|grep pandas windows pip list | findstr pandas 查看4.查看已安装过的包 pip show - -files Somepackage 5.检查哪些包需要更新 pip list - -outdated 升级6.升级包 pip install --upgrade Somepackage 升级pip： python -m pip install --upgrade pip 或者：pip install -U pip","categories":[{"name":"Python","slug":"Python","permalink":"https://changzeyan.github.io/categories/Python/"}],"tags":[{"name":"Pip","slug":"Pip","permalink":"https://changzeyan.github.io/tags/Pip/"}],"author":"ChangzeYan"},{"title":"实体识别","slug":"Python/NLP/实体识别","date":"2021-02-10T01:59:13.000Z","updated":"2021-06-18T11:59:42.100Z","comments":true,"path":"2021/02/10/python/nlp/shi-ti-shi-bie/","link":"","permalink":"https://changzeyan.github.io/2021/02/10/python/nlp/shi-ti-shi-bie/","excerpt":"","text":"实体识别工具Pyhanlp安装先安装JDK。你需要保证JDK位数、操作系统位数和Python位数一致。然后设置JAVA_HOME环境变量，最后执行： # (可选)conda安装jpype1更方便 conda install -c conda-forge jpype1==0.7.0 pip install pyhanlp 检测是否安装成功： hanlp 如果安装成功，会自动下载词典 如果报RuntimeError: module compiled against API version 0xc but this version of numpy is 0xb，需要升级 numpy： pip install --upgrade numpy 交互模式hanlp segment hanlp词性表参考：hanlp词性表 StanfordCoreNLP安装 pip install stanfordcorenlp 由于其源码为 JAVA 编写，所以需要 JDK1.8 及以上版本的支持，下载安装 JDK1.8。下载 StanfordCoreNLP 的相关文件，解压到任意目录 如果要处理中文，还需下载中文jar包：stanford-chinese-corenlp-2018-10-05-models，下载完放到上一步解压后的文件夹中。 调用from stanfordcorenlp import StanfordCoreNLP # 加载模型，路径是上面解压的路径 stanford_model = StanfordCoreNLP(r'./stanford-corenlp-full-2018-02-27', lang='zh') text = \"张三和李四在2019年3月23日在北京的腾讯技术有限公司一起开会。\" res = stanford_model.ner(text) 参数：处理英文时：lang=’en’ kashgari参考： Kashgari:一个方便快捷的命名实体识别、文本分类工具包 NER-使用kashgari中的Bert+BiLSTM+CRF 五分钟搭建一个基于BERT的NER模型 kashgari-zh.bmio.net Kashgari概述 环境准备conda create --envs myTestNER python==3.6 pip insall tensorflow==1.14.0 pip install kashgari==1.1.5 下载模型中文模型 英文模型 数据格式训练集、测试集、验证集的格式均为： 我 O 们 O 变 O 而 O 以 O 书 O 会 O 友 O ， O 把 O 欧 B-LOC 美 B-LOC 流 O 行 O 的 O 食 O 品 O 类 O 图 O 谱 O 、 O 画 O 册 O 读取数据from typing import Tuple, List # 定义一个读取数据的类 class DataReader(object): def read_file(file_path: str, text_index: int = 0, label_index: int = 1) -> Tuple[List[List[str]], List[List[str]]]: \"\"\" 根据文件路径读取训练数据、测试数据以及验证数据的text和label \"\"\" x_data, y_data = [], [] with open(file_path, 'r', encoding='utf-8') as f: lines = f.read().splitlines() # 以splitlines的方式获取数据 x, y = [], [] for line in lines: rows = line.split(' ') # 以空格进行切分 if len(rows) == 1: x_data.append(x) y_data.append(y) x = [] y = [] else: x.append(rows[text_index]) y.append(rows[label_index]) return x_data, y_data 训练import kashgari from kashgari import utils from kashgari.embeddings import BERTEmbedding, BERTEmbeddingV2 from kashgari.tasks.labeling import BiLSTM_CRF_Model from data_load import DataReader kashgari.config.use_cudnn_cell = False # 加载训练数据、验证数据以及测试数据 train_x, train_y = DataReader.read_file('../data/train.txt') test_x, test_y = DataReader.read_file('../data/test.txt') valid_x, valid_y = DataReader.read_file('../data/new_val.txt') print(\"train data count: &amp;#123;len(train_x)&amp;#125;\") print(\"validate data count: &amp;#123;len(valid_x)&amp;#125;\") print(\"test data count: &amp;#123;len(test_x)&amp;#125;\") # 利用kashgari创建Bert Embedding bert_embed = BERTEmbedding('chinese_wwm_ext_L-12_H-768_A-12', task=kashgari.LABELING, sequence_length=100) # 调用BiLSTM_CRF_Model模型并进行训练 model = BiLSTM_CRF_Model(bert_embed) model.fit(x_train=train_x, y_train=train_y, x_validate=valid_x, y_validate=valid_y, batch_size=128, epochs=2) model.save('./model/NER.h5') model.evaluate(test_x, test_y) model.predict([['小', '明', '在', '商', '务', '部']]) 使用自带的人民日报数据import jieba from kashgari.tasks.seq_labeling import BLSTMCRFModel from kashgari.corpus import ChinaPeoplesDailyNerCorpus from kashgari.embeddings import BERTEmbedding embedding = BERTEmbedding('/home/eee/sentence-alignment-classification-model/model/multi_cased_L-12_H-768_A-12', 100) train_x, train_y = ChinaPeoplesDailyNerCorpus.get_sequence_tagging_data('train') validate_x, validate_y = ChinaPeoplesDailyNerCorpus.get_sequence_tagging_data('validate') test_x, test_y = ChinaPeoplesDailyNerCorpus.get_sequence_tagging_data('test') model = BLSTMCRFModel(embedding) model.fit(train_x, train_y, validate_y=validate_y, validate_x=validate_x, epochs=200, batch_size=500) model.save('./model') new_model = BLSTMCRFModel.load_model('./model') # EXAMPLE 1 news = \"「DeepMind 击败人类职业玩家的方式与他们声称的 AI 使命，以及所声称的『正确』方式完全相反。」\" x = list(jieba.cut(news)) >>> x ['「', 'DeepMind', ' ', '击败', '人类', '职业', '玩家', '的', '方式', '与', '他们', '声称', '的', ' ', 'AI', ' ', '使命', '，', '以及', '所', '声称', '的', '『', '正确', '』', '方式', '完全', '相反', '。', '」'] >>> new_model.predict(x) ['O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O'] # EXAMPLE 2 news = \"陈志衍是有个非常好的男孩子，他住在香港的九龙塘区，他今年二十三号生日。\" x = list(jieba.cut(news)) >>> x ['陈志衍', '是', '有', '个', '非常', '好', '的', '男孩子', '，', '他', '住', '在', '香港', '的', '吉林', '区', '，', '他', '今年', '二十三', '号', '生日', '。'] >>> new_model.predict(x) ['O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O'] 自带数据集加载内置数据集 中文数据集 from kashgari.corpus import ChineseDailyNerCorpus train_x, train_y = ChineseDailyNerCorpus.load_data(&#39;train&#39;) valid_x, valid_y = ChineseDailyNerCorpus.load_data(&#39;valid&#39;) test_x, test_y = ChineseDailyNerCorpus.load_data(&#39;test&#39;) 英文数据集 from kashgari.corpus import CONLL2003ENCorpus train_x, train_y = CONLL2003ENCorpus.load_data(&#39;train&#39;) valid_x, valid_y = CONLL2003ENCorpus.load_data(&#39;valid&#39;) test_x, test_y = CONLL2003ENCorpus.load_data(&#39;test&#39;) # 也可以使用自己的数据集 train_x = [[&#39;Hello&#39;, &#39;world&#39;], [&#39;Hello&#39;, &#39;Kashgari&#39;], [&#39;I&#39;, &#39;love&#39;, &#39;Beijing&#39;]] train_y = [[&#39;O&#39;, &#39;O&#39;], [&#39;O&#39;, &#39;B-PER&#39;], [&#39;O&#39;, &#39;B-LOC&#39;]] valid_x, valid_y = train_x, train_y test_x, test_x = train_x, train_y stanzaLTP参考：LTP4 文档 安装pip install ltp 加载模型from ltp import LTP ltp = LTP() # 默认加载 Small 模型 # ltp = LTP(path = &quot;base|small|tiny&quot;) # ltp = LTP(path = &quot;tiny.tgz|tiny-tgz-extracted&quot;) # 其中 tiny-tgz-extracted 是 tiny.tgz 解压出来的文件夹 命名实体识别from ltp import LTP ltp = LTP() seg, hidden = ltp.seg([&quot;他叫汤姆去拿外衣。&quot;]) ner = ltp.ner(hidden) # [[&#39;他&#39;, &#39;叫&#39;, &#39;汤姆&#39;, &#39;去&#39;, &#39;拿&#39;, &#39;外衣&#39;, &#39;。&#39;]] # [[(&#39;Nh&#39;, 2, 2)]] tag, start, end = ner[0][0] print(tag,&quot;:&quot;, &quot;&quot;.join(seg[0][start:end + 1])) # Nh : 汤姆","categories":[{"name":"Python","slug":"Python","permalink":"https://changzeyan.github.io/categories/Python/"}],"tags":[{"name":"NLP","slug":"NLP","permalink":"https://changzeyan.github.io/tags/NLP/"}],"author":"ChangzeYan"},{"title":"Python-str","slug":"Python/Python语法/Python-str","date":"2021-01-28T08:05:26.000Z","updated":"2021-09-26T09:19:06.396Z","comments":true,"path":"2021/01/28/python/python-yu-fa/python-str/","link":"","permalink":"https://changzeyan.github.io/2021/01/28/python/python-yu-fa/python-str/","excerpt":"","text":"字符串拼接多个字符串拼接可以用join: str_list = ['Hello', 'world'] str_join1 = ' '.join(str_list) str_join2 = '-'.join(str_list) print(str_join1) >>>Hello world print(str_join2) >>>Hello-world 加号拼接: str_1 = 'Hello world！ ' str_2 = 'My name is Python猫.' print(str_1 + str_2) >>>Hello world！ My name is Python猫. print(str_1) >>>Hello world！ 字符串增长： str += &#39;s&#39;","categories":[{"name":"Python","slug":"Python","permalink":"https://changzeyan.github.io/categories/Python/"}],"tags":[{"name":"String","slug":"String","permalink":"https://changzeyan.github.io/tags/String/"}],"author":"ChangzeYan"},{"title":"Mongo语法","slug":"Linux/Mongo/Mongo-grammar","date":"2021-01-28T07:54:30.000Z","updated":"2021-06-17T01:23:42.260Z","comments":true,"path":"2021/01/28/linux/mongo/mongo-grammar/","link":"","permalink":"https://changzeyan.github.io/2021/01/28/linux/mongo/mongo-grammar/","excerpt":"","text":"查询查询所有db.collection.find() 获取数据条数db.collection.find().count() 范围查询查询age>22的记录 db.userInfo.find((age:&amp;#123;$gt:22&amp;#125;&amp;#125;); 查询age&lt;22的记录 db.userInfo.find(&amp;#123;age:&amp;#123;$lt:22&amp;#125;&amp;#125;); 查询age>=25的记录 db.userInfo.find(&amp;#123;age:&amp;#123;$gte:25&amp;#125;&amp;#125;); 查询age&lt;=25的记录 db.userInfo.find(&amp;#123;age:&amp;#123;$lte:25&amp;#125;&amp;#125;); 查询age>23并且age&lt;=26 db.userInfo.find(&amp;#123;age:&amp;#123;gte:23,$lte:26&amp;#125;&amp;#125;); and查询student 集合中名字为zs且id为02的项: db.getCollection(\"student\").find(&amp;#123;\"name\":\"zs\",\"id\":\"02\"&amp;#125;) 查询集合中指定字段的所有不同值db.目标集合.distinct(&quot;指定字段&quot;)","categories":[{"name":"Liunx","slug":"Liunx","permalink":"https://changzeyan.github.io/categories/Liunx/"}],"tags":[{"name":"Mongo","slug":"Mongo","permalink":"https://changzeyan.github.io/tags/Mongo/"}],"author":"ChangzeYan"},{"title":"Linux安装Python3.6","slug":"Linux/命令/Install-Python3-6","date":"2021-01-27T11:26:20.000Z","updated":"2021-01-27T11:50:44.419Z","comments":true,"path":"2021/01/27/linux/ming-ling/install-python3-6/","link":"","permalink":"https://changzeyan.github.io/2021/01/27/linux/ming-ling/install-python3-6/","excerpt":"","text":"参考: Centos7安装python3.6.5 安装python3.6.5,原来的python2.7并存 安装依赖yum install openssl-devel bzip2-devel expat-devel gdbm-devel readline-devel sqlite-devel wget 下载安装包: wget https://www.python.org/ftp/python/3.6.5/Python-3.6.5.tgz 解压文件: tar -zxvf Python-3.6.5.tgz 进入 解压后的目录,指定编译后文件的目录: cd Python-3.6.5.tgz ./configure --prefix=/usr/local/python3 编译: make &amp;&amp; make install 如果出现zipimport.ZipImportError: can’t decompress data; zlib not avaliable,则安装: yum install -y zlib* 然后重新执行make 设置软链查看 /usr/bin下是否有pip3和python3,如果没有设置下面的软链: ln -s /usr/local/python3/bin/python3 /usr/bin/python3 ln -s /usr/local/python3/bin/pip3 /usr/bin/pip3","categories":[{"name":"Linux","slug":"Linux","permalink":"https://changzeyan.github.io/categories/Linux/"}],"tags":[{"name":"Install","slug":"Install","permalink":"https://changzeyan.github.io/tags/Install/"}],"author":"ChangzeYan"},{"title":"更新Centos内核","slug":"Linux/命令/update-centos-core","date":"2021-01-27T10:51:13.000Z","updated":"2021-01-27T11:07:20.434Z","comments":true,"path":"2021/01/27/linux/ming-ling/update-centos-core/","link":"","permalink":"https://changzeyan.github.io/2021/01/27/linux/ming-ling/update-centos-core/","excerpt":"","text":"参考: Centos7 升级内核版本 查看当前内核版本内核版本 $ uname -r 3.10.0-514.el7.x86_64 $ uname -a Linux k8s-master 3.10.0-514.el7.x86_64 #1 SMP Tue Nov 22 16:42:41 UTC 2016 x86_64 x86_64 x86_64 GNU/Linux centos版本： $ cat /etc/redhat-release CentOS Linux release 7.3.1611 (Core) 升级内核更新yum源仓库$ yum -y update 启用 ELRepo 仓库ELRepo 仓库是基于社区的用于企业级 Linux 仓库，提供对 RedHat Enterprise (RHEL) 和 其他基于 RHEL的 Linux 发行版（CentOS、Scientific、Fedora 等）的支持。ELRepo 聚焦于和硬件相关的软件包，包括文件系统驱动、显卡驱动、网络驱动、声卡驱动和摄像头驱动等。 #导入ELRepo仓库的公共密钥 rpm --import https://www.elrepo.org/RPM-GPG-KEY-elrepo.org #安装ELRepo仓库的yum源 rpm -Uvh http://www.elrepo.org/elrepo-release-7.0-3.el7.elrepo.noarch.rpm 查看可用的系统内核包yum --disablerepo=\"*\" --enablerepo=\"elrepo-kernel\" list available 安装最新版本内核yum --enablerepo=elrepo-kernel install kernel-ml –enablerepo 选项开启 CentOS 系统上的指定仓库。默认开启的是 elrepo，这里用 elrepo-kernel 替换。 设置 grub2内核安装好后，需要设置为默认启动选项并重启后才会生效 查看系统上的所有可用内核$ sudo awk -F\\' '$1==\"menuentry \" &amp;#123;print i++ \" : \" $2&amp;#125;' /etc/grub2.cfg 0 : CentOS Linux (4.18.7-1.el7.elrepo.x86_64) 7 (Core) 1 : CentOS Linux (3.10.0-862.11.6.el7.x86_64) 7 (Core) 2 : CentOS Linux (3.10.0-514.el7.x86_64) 7 (Core) 3 : CentOS Linux (0-rescue-063ec330caa04d4baae54c6902c62e54) 7 (Core) 设置新的内核为grub2的默认版本服务器上存在4 个内核，我们要使用 4.18 这个版本，可以通过 grub2-set-default 0 命令或编辑 /etc/default/grub 文件来设置 方法1、通过 grub2-set-default 0 命令设置其中 0 是上面查询出来的可用内核编号 grub2-set-default 0 方法2、编辑 /etc/default/grub 文件设置 GRUB_DEFAULT=0，通过上面查询显示的编号为 0 的内核作为默认内核： $ vim /etc/default/grub GRUB_TIMEOUT=5 GRUB_DISTRIBUTOR=\"$(sed 's, release .*$,,g' /etc/system-release)\" GRUB_DEFAULT=0 GRUB_DISABLE_SUBMENU=true GRUB_TERMINAL_OUTPUT=\"console\" GRUB_CMDLINE_LINUX=\"crashkernel=auto rd.lvm.lv=cl/root rhgb quiet\" GRUB_DISABLE_RECOVERY=\"true\" 生成 grub 配置文件并重启 grub2-mkconfig -o /boot/grub2/grub.cfg reboot 验证$ uname -r 4.18.7-1.el7.elrepo.x86_64 删除旧内核（可选）查看系统中全部的内核： $ rpm -qa | grep kernel kernel-3.10.0-514.el7.x86_64 kernel-ml-4.18.7-1.el7.elrepo.x86_64 kernel-tools-libs-3.10.0-862.11.6.el7.x86_64 kernel-tools-3.10.0-862.11.6.el7.x86_64 kernel-3.10.0-862.11.6.el7.x86_64 方法1、yum remove 删除旧内核的 RPM 包$ yum remove kernel-3.10.0-514.el7.x86_64 \\ kernel-tools-libs-3.10.0-862.11.6.el7.x86_64 \\ kernel-tools-3.10.0-862.11.6.el7.x86_64 \\ kernel-3.10.0-862.11.6.el7.x86_64 方法2、yum-utils 工具如果安装的内核不多于 3 个，yum-utils 工具不会删除任何一个。只有在安装的内核大于 3 个时，才会自动删除旧内核。安装yum-utils $ yum install yum-utils 删除旧版本 package-cleanup --oldkernels","categories":[{"name":"Linux","slug":"Linux","permalink":"https://changzeyan.github.io/categories/Linux/"}],"tags":[],"author":"ChangzeYan"},{"title":"Python-堆","slug":"Python/Python语法/python-heap","date":"2021-01-26T04:05:51.000Z","updated":"2021-02-01T10:39:51.872Z","comments":true,"path":"2021/01/26/python/python-yu-fa/python-heap/","link":"","permalink":"https://changzeyan.github.io/2021/01/26/python/python-yu-fa/python-heap/","excerpt":"","text":"使用from heapq import * # 建立堆 heap=[] # 将x压入堆中 heappush(heap, x) # 从堆中弹出最小的元素 heappop(heap) # 让列表具备堆特征，函数heapify通过执行尽可能少的移位操作将列表变成合法的堆（即具备堆特征）。如果你的堆并不是使用heappush创建的，应在使用heappush和heappop之前使用这个函数。 heapify(heap) # 弹出最小的元素，并将x压入堆中 heapreplace(heap, x) # 返回iter中n个最大的元素 nlargest(n, iter) # 返回iter中n个最小的元素 nsmallest(n, iter) 自定义排序class Document: def __init__(self, _id, con, goal): self.id = str(_id) self.content = con self.goal = goal # 按照goal，从小到大排序 def __lt__(self, other): if self.goal &lt; other.goal: return True else: return False d1=Document('1',\"fda\",23) d2=Document('2',\"fda\",2) d3=Document('3',\"fda\",245) li=[d1,d2,d3] li.sort()","categories":[{"name":"Python","slug":"Python","permalink":"https://changzeyan.github.io/categories/Python/"}],"tags":[{"name":"Heap","slug":"Heap","permalink":"https://changzeyan.github.io/tags/Heap/"}],"author":"ChangzeYan"},{"title":"Java-ConnectKafka","slug":"Linux/kafka/Java-ConnectKafka","date":"2021-01-07T01:58:00.000Z","updated":"2021-01-07T01:59:36.599Z","comments":true,"path":"2021/01/07/linux/kafka/java-connectkafka/","link":"","permalink":"https://changzeyan.github.io/2021/01/07/linux/kafka/java-connectkafka/","excerpt":"","text":"从头开始消费消费者要从头开始消费某个topic的全量数据，需要满足2个条件（spring-kafka）： 使用一个全新的”group.id”（就是之前没有被任何消费者使用过）; 指定”auto.offset.reset”参数的值为earliest；","categories":[{"name":"Kafka","slug":"Kafka","permalink":"https://changzeyan.github.io/categories/Kafka/"}],"tags":[{"name":"Java-Kafka","slug":"Java-Kafka","permalink":"https://changzeyan.github.io/tags/Java-Kafka/"}],"author":"ChangzeYan"},{"title":"Latex-table","slug":"write/Latex/latex-table","date":"2021-01-06T03:37:01.000Z","updated":"2021-05-23T13:10:26.572Z","comments":true,"path":"2021/01/06/write/latex/latex-table/","link":"","permalink":"https://changzeyan.github.io/2021/01/06/write/latex/latex-table/","excerpt":"","text":"三线表\\vspace{-0.5em}用于设置与表标题之间的距离 \\begin&#123;table&#125;[!ht] \\bicaption&#123;八种DNA编码规则&#125;&#123;Eight kinds of DNA coding rules.&#125; \\label&#123;tab:atcg&#125; \\vspace&#123;-0.5em&#125;\\centering\\wuhao \\begin&#123;tabular&#125;&#123;cccc&#125; \\toprule 词 &amp; 经济 &amp; 政治 &amp; 体育 \\\\ \\midrule “冠军” &amp; -6.9077 &amp; -6.9077 &amp; 0.6931\\\\ \\bottomrule \\end&#123;tabular&#125; \\end&#123;table&#125; 设置表格列宽参考：Latex设定表格列宽 固定列宽可以使用 array 宏包的 p{2cm} 系列命令，如果需要指定水平对齐方式，可以使用下面的形式 &gt;{\\centering}p{2cm} 实现，但如果使用这种方式，缺省情况下不能使用 \\ 换行，需要使用\\tabularnewline 代替。为了仍然使用 \\ 换行，需要在导言区加上下面的代码： \\usepackage&#123;array&#125; \\newcommand&#123;\\PreserveBackslash&#125;[1]&#123;\\let\\temp=\\\\#1\\let\\\\=\\temp&#125; \\newcolumntype&#123;C&#125;[1]&#123;&gt;&#123;\\PreserveBackslash\\centering&#125;p&#123;#1&#125;&#125; \\newcolumntype&#123;R&#125;[1]&#123;&gt;&#123;\\PreserveBackslash\\raggedleft&#125;p&#123;#1&#125;&#125; \\newcolumntype&#123;L&#125;[1]&#123;&gt;&#123;\\PreserveBackslash\\raggedright&#125;p&#123;#1&#125;&#125; 使用 C{3cm} 命令即可指定该列宽度为 3cm，并且文字居中对齐，左对齐和右对齐命令分别是 L{2cm} 和R{2cm}。 \\begin&#123;table&#125;[htbp] \\centering\\caption&#123;\\label&#123;tab:test&#125;2000 和~2004 年中国制造业产品的出口份额&#125; \\begin&#123;tabular&#125;&#123;L&#123;2cm&#125;C&#123;2cm&#125;R&#123;2cm&#125;&#125; \\toprule &amp; 2000 &amp; 2004 \\\\ \\midrule 钢铁 &amp; 3.1 &amp; 5.2 \\\\ 化学制品 &amp; 2.1 &amp; 2.7 \\\\ 办公设备及电信设备 &amp; 4.5 &amp; 15.2 \\\\ 汽车产品 &amp; 0.3 &amp; 0.7 \\\\ 纺织品 &amp; 10.4 &amp; 17.2 \\\\ 服装 &amp; 18.3 &amp; 24\\\\ \\bottomrule \\end&#123;tabular&#125; \\end&#123;table&#125;","categories":[{"name":"Latex","slug":"Latex","permalink":"https://changzeyan.github.io/categories/Latex/"}],"tags":[{"name":"Latex-table","slug":"Latex-table","permalink":"https://changzeyan.github.io/tags/Latex-table/"}],"author":"ChangzeYan"},{"title":"Latex-pic","slug":"write/Latex/latex-pic","date":"2021-01-06T02:06:37.000Z","updated":"2021-06-12T13:31:21.820Z","comments":true,"path":"2021/01/06/write/latex/latex-pic/","link":"","permalink":"https://changzeyan.github.io/2021/01/06/write/latex/latex-pic/","excerpt":"","text":"设置图片存放路径设置存放图片的根路径导包： \\usepackage&#123;graphicx&#125; 使用：在根目录下建立figures目录，将图片存放在该目录中，以后直接引用图片名称即可，不用扩展名： \\graphicspath&#123;&#123;figures/&#125;&#125; 插入图片isNumberDFA是图片名，不用加扩展名： \\begin&#123;figure&#125;[htb] \\centering % 调整图片与标题之间的距离 \\setlength&#123;\\abovecaptionskip&#125;&#123;0.5em&#125; \\includegraphics[width=1\\textwidth]&#123;isNumberDFA&#125; \\caption&#123;DFA状态转移图&#125; \\label&#123;isNumberDFA&#125; \\end&#123;figure&#125; 两张图片横着放\\begin&#123;figure&#125;[htb] \\centering \\subfigure[冠状树]&#123; \\begin&#123;minipage&#125;[b]&#123;0.4\\textwidth&#125; \\includegraphics[width=1\\textwidth]&#123;isNumberDFA&#125; \\end&#123;minipage&#125; &#125; \\subfigure[龙曲线]&#123; \\begin&#123;minipage&#125;[b]&#123;0.4\\textwidth&#125; \\includegraphics[width=1\\textwidth]&#123;status-table-DFA&#125; \\end&#123;minipage&#125; &#125; \\caption&#123;DFA状态转移图&#125; \\label&#123;isNumberDFA&#125; \\end&#123;figure&#125; 四张图片两两并列排放空行表示换行。 \\begin&#123;figure&#125;[H] \\centering \\begin&#123;minipage&#125;&#123;7cm&#125; \\includegraphics[width=1\\textwidth]&#123;./pic/info1&#125; \\label&#123;1&#125; \\end&#123;minipage&#125; \\begin&#123;minipage&#125;&#123;7cm&#125; \\includegraphics[width=1\\textwidth]&#123;./pic/info2&#125; \\label&#123;2&#125; \\end&#123;minipage&#125; % 空一行会分两行排版 \\begin&#123;minipage&#125;&#123;7cm&#125; \\includegraphics[width=\\textwidth]&#123;./pic/info3&#125; \\label&#123;3&#125; \\end&#123;minipage&#125; \\begin&#123;minipage&#125;&#123;7cm&#125; \\includegraphics[width=\\textwidth]&#123;./pic/info4&#125; \\label&#123;4&#125; \\end&#123;minipage&#125; \\caption&#123;填写信息&#125; \\end&#123;figure&#125; 九张图片\\begin&#123;figure&#125;[htb] \\centering \\subfigure[冠状树]&#123; \\label&#123;xx&#125; \\begin&#123;minipage&#125;[b]&#123;0.3\\textwidth&#125; \\includegraphics[width=1\\textwidth]&#123;runcoronaltree&#125; \\end&#123;minipage&#125; &#125; \\subfigure[龙曲线]&#123; \\label&#123;xx&#125; \\begin&#123;minipage&#125;[b]&#123;0.3\\textwidth&#125; \\includegraphics[width=1\\textwidth]&#123;rundragon&#125; \\end&#123;minipage&#125; &#125; \\subfigure[丢勒五边形]&#123; \\label&#123;xx&#125; \\begin&#123;minipage&#125;[b]&#123;0.3\\textwidth&#125; \\includegraphics[width=1\\textwidth]&#123;rundurer&#125; \\end&#123;minipage&#125; &#125; \\subfigure[蕨类植物]&#123; \\label&#123;fern0&#125; \\begin&#123;minipage&#125;[b]&#123;0.3\\textwidth&#125; \\includegraphics[width=1\\textwidth]&#123;runfern0&#125; \\end&#123;minipage&#125; &#125; \\subfigure[鱼群]&#123; \\begin&#123;minipage&#125;[b]&#123;0.3\\textwidth&#125; \\includegraphics[width=1\\textwidth]&#123;runfish&#125; \\end&#123;minipage&#125; &#125; \\subfigure[树]&#123; \\begin&#123;minipage&#125;[b]&#123;0.3\\textwidth&#125; \\includegraphics[width=1\\textwidth]&#123;runtree&#125; \\end&#123;minipage&#125; &#125; \\subfigure[c曲线]&#123; \\begin&#123;minipage&#125;[b]&#123;0.3\\textwidth&#125; \\includegraphics[width=1\\textwidth]&#123;runc&#125; \\end&#123;minipage&#125; &#125; \\subfigure[枫树]&#123; \\begin&#123;minipage&#125;[b]&#123;0.3\\textwidth&#125; \\includegraphics[width=1\\textwidth]&#123;runmapletree&#125; \\end&#123;minipage&#125; &#125; \\subfigure[Sierpinski三角形]&#123; \\begin&#123;minipage&#125;[b]&#123;0.3\\textwidth&#125; \\includegraphics[width=1\\textwidth]&#123;runsierpinski&#125; \\end&#123;minipage&#125; &#125; \\caption&#123;程序运行结果&#125; \\label&#123;runresult&#125; \\end&#123;figure&#125; 图标题\\vspace&#123;-0.8cm&#125; %调整图片与上文的垂直距离 \\setlength&#123;\\abovecaptionskip&#125;&#123;-0.2cm&#125; %调整图片标题与图距离 \\setlength&#123;\\belowcaptionskip&#125;&#123;-1cm&#125; %调整图片标题与下文距离 图片超过宽度会导致图片标题与下文之间间隔变大。减少宽度即可：设置为行宽的90% \\includegraphics[width = 0.9\\textwidth]&#123;picname&#125; 子标题与子图的距离参考：subfigure命令插入多行多列图片修改子图与子图、子标题的距离\\subfigcapskip=-5pt %设置子图与子标题之间的距离 \\usepackage&#123;graphicx&#125; %插入图片的宏包 \\usepackage&#123;float&#125; %设置图片浮动位置的宏包 \\usepackage&#123;subfigure&#125; %插入多图时用子图显示的宏包 \\begin&#123;figure&#125;[H] %这里使用的是强制位置，除非真的放不下，不然就是写在哪里图就放在哪里，不会乱动 \\centering %图片全局居中 \\vspace&#123;-0.35cm&#125; %设置与上面正文的距离 \\subfigtopskip=2pt %设置子图与上面正文或别的内容的距离 \\subfigbottomskip=2pt %设置第二行子图与第一行子图的距离，即下面的头与上面的脚的距离 \\subfigcapskip=-5pt %设置子图与子标题之间的距离 \\subfigure[original]&#123; \\label&#123;level.sub.1&#125; \\includegraphics[width=0.32\\linewidth]&#123;./figure/original.png&#125;&#125; \\quad %默认情况下两个子图之间空的较少，使用这个命令加大宽度 \\subfigure[level=9]&#123; \\label&#123;level.sub.2&#125; \\includegraphics[width=0.32\\linewidth]&#123;./figure/level9.png&#125;&#125; %这里是空了一行，能够实现强制将四张图分成两行两列显示，而不是放不下图了再换行，使用\\\\也行。 \\subfigure[level=8]&#123; \\label&#123;level.sub.3&#125; \\includegraphics[width=0.32\\linewidth]&#123;./figure/level8.png&#125;&#125; \\quad \\subfigure[level=7]&#123; \\label&#123;level.sub.4&#125; \\includegraphics[width=0.32\\linewidth]&#123;./figure/level7.png&#125;&#125; \\caption&#123;不同level的渲染效果&#125; \\label&#123;level&#125; \\end&#123;figure&#125;","categories":[{"name":"Latex","slug":"Latex","permalink":"https://changzeyan.github.io/categories/Latex/"}],"tags":[{"name":"Latex-pic","slug":"Latex-pic","permalink":"https://changzeyan.github.io/tags/Latex-pic/"}],"author":"ChangzeYan"},{"title":"Java-IO","slug":"Java/Java-IO","date":"2021-01-05T14:40:25.000Z","updated":"2022-01-12T10:05:43.997Z","comments":true,"path":"2021/01/05/java/java-io/","link":"","permalink":"https://changzeyan.github.io/2021/01/05/java/java-io/","excerpt":"","text":"读文件一行一行地读： public String readFile()&amp;#123; String path = \"\"; File file = new File(path); StringBuilder result = new StringBuilder(); try&amp;#123; BufferedReader br = new BufferedReader(new InputStreamReader(new FileInputStream(file), \"UTF-8\"));//构造一个BufferedReader类来读取文件 String s = null; while((s = br.readLine())!=null)&amp;#123;//使用readLine方法，一次读一行 result.append( System.lineSeparator() + s); &amp;#125; br.close(); &amp;#125;catch(Exception e)&amp;#123; e.printStackTrace(); &amp;#125; return result.toString(); &amp;#125;","categories":[{"name":"Java","slug":"Java","permalink":"https://changzeyan.github.io/categories/Java/"}],"tags":[{"name":"IO","slug":"IO","permalink":"https://changzeyan.github.io/tags/IO/"}],"author":"ChangzeYan"},{"title":"Latex-字体","slug":"write/Latex/Latex-字体","date":"2021-01-05T11:02:25.000Z","updated":"2021-01-06T03:51:34.818Z","comments":true,"path":"2021/01/05/write/latex/latex-zi-ti/","link":"","permalink":"https://changzeyan.github.io/2021/01/05/write/latex/latex-zi-ti/","excerpt":"","text":"字体设置英文字体单独设置： \\usepackage&#123;ctex&#125; \\rmfamily&#123;Kafka&#125;和\\rmfamily&#123;RocketMQ&#125;的调研报告&#125; 字号大小对应关系 字号 磅(pt) 毫米数 初号 42 14.28 小初 36 12.70 一号 26 9.17 小一 24 8.47 二号 22 7.76 小二 18 6.35 三号 16 5.64 小三 15 5.29 四号 14 4.94 小四 12 4.32 五号 10.5 3.70","categories":[{"name":"Latex","slug":"Latex","permalink":"https://changzeyan.github.io/categories/Latex/"}],"tags":[{"name":"Latex-字体","slug":"Latex-字体","permalink":"https://changzeyan.github.io/tags/Latex-%E5%AD%97%E4%BD%93/"}],"author":"ChangzeYan"},{"title":"搭建kafka集群","slug":"Linux/kafka/搭建kafka集群","date":"2021-01-05T02:27:18.000Z","updated":"2021-01-06T02:55:10.614Z","comments":true,"path":"2021/01/05/linux/kafka/da-jian-kafka-ji-qun/","link":"","permalink":"https://changzeyan.github.io/2021/01/05/linux/kafka/da-jian-kafka-ji-qun/","excerpt":"","text":"搭建zookeeper集群参考：centos7安装zookeeper3.4.12集群 环境准备三台服务器，已经做了ssh免密登录，都安装了jdk8 master: 192.168.244.5 slave1: 192.168.244.6 slave2: 192.168.244.7 下载和解压zookeeper历史版本本次使用版本：zookeeper-3.4.12.tar.gz在三台服务器都建立 /opt/software目录 mkdir -p /opt/software 将安装包上传到master服务器，解压： tar -xzvf zookeeper-3.4.12.tar.gz -C /opt/software 配置mv /opt/software/zookeeper-3.4.12/conf/zoo_sample.cfg /opt/software/zookeeper-3.4.12/conf/zoo.cfg vi /opt/software/zookeeper-3.4.12/conf/zoo.cfg 注释掉dataDir=/tmp/zookeeper，然后在文件末尾添加： dataDir=/opt/software/zookeeper-3.4.12/data dataLogDir=/opt/software/zookeeper-3.4.12/log # 主机名可以用对应ip代替 server.1=master:2888:3888 server.2=slave1:2888:3888 server.3=slave2:2888:3888 创建myid文件： mkdir -p /opt/software/zookeeper-3.4.12/data #创建数据目录，该目录在zoo.cfg中配置 cd /opt/software/zookeeper-3.4.12/data #上面配置的zookeeper数据保存目录 touch myid #创建myid文件 echo \"1\">>myid #往myid中写入1，对应server.X=&amp;#123;IP&amp;#125;:2888:3888 中的x数字 将上面在master机器上配置好的zookeeper复制到slave1,slave2两台机器上去： scp -r /opt/software/zookeeper-3.4.12/ slave1:/opt/software/ scp -r /opt/software/zookeeper-3.4.12/ slave2:/opt/software/ 修改slave1,slave2机器上/opt/software/zookeeper-3.4.12/data/myid为对应的值：slave1中： cd /opt/software/zookeeper-3.4.12/data rm -f ./myid echo \"2\">>myid slave2中： cd /opt/software/zookeeper-3.4.12/data rm -f ./myid echo \"3\">>myid #往myid中写入3，对应server.X=&amp;#123;IP&amp;#125;:2888:3888 中的x数字,此处为3 配置环境变量vim /etc/profile 在PATH后添加：:$ZK_HOME/bin export ZK_HOME=/opt/software/zookeeper-3.4.12 export PATH=XXXXXXX:$ZK_HOME/bin 使环境变量生效： source /etc/profile 三台服务器都配置环境变量。 启动zookeeper三台服务器都执行： zkServer.sh start zookeeper命令# 启动ZK服务 sh zkServer.sh start # 查看ZK服务状态: sh zkServer.sh status # 停止ZK服务: sh zkServer.sh stop # 重启ZK服务 sh zkServer.sh restart # 客户端连接zookeeper zkCli.sh -server master:2181 搭建Kafka参考： Centos7搭建kafka集群 centos7搭建kafka集群 下载历史版本本文选择kafka_2.13-2.4.0.tgz。上传到master /opt/software下，解压： tar -zxvf kafka_2.12-2.6.0.tgz 配置修改server.properties: vi /opt/software/kafka_2.13-2.4.0/config/server.properties # 修改如下内容 // 依次增长的整数，0、1、2，集群中Broker的唯一id broker.id：0 advertised.listeners=PLAINTEXT://192.168.244.5:9092 zookeeper.connect=192.168.244.5:2181,192.168.244.6:2181,192.168.244.7:2181 修改/opt/software/kafka_2.13-2.4.0/config/zookeeper.properties中的dataDir： dataDir=/opt/software/zookeeper-3.4.12/data 分发到其他两个节点： scp -r /opt/software/kafka_2.13-2.4.0/ slave1:/opt/software/ scp -r /opt/software/kafka_2.13-2.4.0/ slave2:/opt/software/ 修改其它节点配置文件 #slave1节点 vi /opt/software/kafka_2.13-2.4.0/config/server.properties # The id of the broker. This must be set to a unique integer for each broker. broker.id=1 advertised.listeners=PLAINTEXT://192.168.244.6:9092 #slave2节点 vi /opt/software/kafka_2.13-2.4.0/config/server.properties # The id of the broker. This must be set to a unique integer for each broker. broker.id=2 advertised.listeners=PLAINTEXT://192.168.244.7:9092 启动三台服务器在/opt/software/kafka_2.13-2.4.0/bin/下： ./kafka-server-start.sh -daemon ../config/server.properties kafka命令由于配置了环境变量，所以可以直接执行： # 启动kafka kafka-server-start.sh -daemon ../config/server.properties # 停止 ./kafka-server-stop.sh # 查看topic kafka-topics.sh --list --zookeeper master:2181,slave1:2181,slave2:2181 # 创建topic，replication-factor设置副本的数量，不能超过broker数量 kafka-topics.sh --create --zookeeper master:2181,slave1:2181,slave2:2181 --replication-factor 1 --partitions 1 --topic test # 发送消息 kafka-console-producer.sh --broker-list master:9092,slave1:9092,slave2:9092 --topic test # 接收消息 kafka-console-consumer.sh --bootstrap-server master:9092,slave1:9092,slave2:9092 --topic test --from-beginning 安装中的问题kafka无法启动master中原来安装过单机版kafka，启动时报错（在/opt/software/kafka_2.13-2.4.0/logs/server.log中）： ERROR Fatal error during KafkaServer startup. Prepare to shutdown (kafka.server.KafkaServer) kafka.common.InconsistentClusterIdException: The Cluster ID Reu8ClK3TTywPiNLIQIm1w doesn\\'t match stored clusterId Some(BaPSk1bCSsKFxQQ4717R6Q) in meta.properties. The broker is trying to join the wrong cluster. Configured zookeeper.connect may be wrong. at kafka.server.KafkaServer.startup(KafkaServer.scala:220) at kafka.server.KafkaServerStartable.startup(KafkaServerStartable.scala:44) at kafka.Kafka$.main(Kafka.scala:84) at kafka.Kafka.main(Kafka.scala) 参考：kafka.common.InconsistentClusterIdException) 原因是两个kafka占用了同一个kafka日志目录（存放topic的目录）。 解决 停止三台服务器中zookeeper和kafka。 删除 三个服务器以下内容： /opt/software/kafka_2.13-2.4.0/logs 下所有内容 /opt/software/zookeeper-3.4.12/log 下所有内容 /opt/software/zookeeper-3.4.12/data 下除了myid外所有内容 在三台服务器下新建kafka日志目录： mkdir -p /opt/software/kafka_2.13-2.4.0/kafka-logs 修改/opt/software/kafka_2.13-2.4.0/config/server.properties中配置的kafka日志目录，三台服务器都需要修改： vi /opt/software/kafka_2.13-2.4.0/config/server.properties log.dirs=/opt/software/kafka_2.13-2.4.0/kafka-logs 然后重新启动zookeeper和kafka。 zookeeper ConnectException启动zookeeper后发现/opt/software/zookeeper-3.4.12/data/zookeeper.out中报错： 解决参考：[WARN [WorkerSender[myid=1]:QuorumCnxManager@584] - Cannot open channel to 2 at election address /x.x.x.x:3888](https://www.cnblogs.com/chuijingjing/p/10907244.html) 如果是刚启动zookeeper报出这个错误，然后不再不错，那就是正常现象。是由于有的节点启动，而有的节点还没有启动，这段时间已经启动的节点就会去努力寻找没有启动的节点，就会报出这样的错误。这是一种正常现象，无需多虑。 如果启动很长时间之后还在报错，可以尝试：修改每个节点的zoo.cfg文件中的相对应的server.x=0.0.0.0:2888:3888 # master: server.1=0.0.0.0:2888:3888 server.2=slave1:2888:3888 server.3=slave2:2888:3888 # slave1: server.1=master:2888:3888 server.2=0.0.0.0:2888:3888 server.3=slave2:2888:3888 # slave2: server.1=master:2888:3888 server.2=slave1:2888:3888 server.3=0.0.0.0:2888:3888","categories":[{"name":"Linux","slug":"Linux","permalink":"https://changzeyan.github.io/categories/Linux/"}],"tags":[{"name":"Kafka","slug":"Kafka","permalink":"https://changzeyan.github.io/tags/Kafka/"}],"author":"ChangzeYan"},{"title":"安装镜像","slug":"Docker/安装镜像","date":"2021-01-04T10:35:42.000Z","updated":"2021-01-04T12:59:00.255Z","comments":true,"path":"2021/01/04/docker/an-zhuang-jing-xiang/","link":"","permalink":"https://changzeyan.github.io/2021/01/04/docker/an-zhuang-jing-xiang/","excerpt":"","text":"Kafka参考：Docker快速搭建Kafka 1.x集群windows下，安装docker时默认安装了docker-compose，可以执行测试： docker-compose -v 编写docker-compose.ymlversion: '2' services: zookeeper: image: \"zookeeper\" hostname: \"zookeeper.local\" container_name: \"zookeeper\" #设置网络别名 networks: local: aliases: - \"zookeeper.local\" kafka: image: \"wurstmeister/kafka\" hostname: \"kafka.local\" container_name: \"kafka\" ports: - \"9092:9092\" networks: local: aliases: - \"kafka.local\" environment: KAFKA_ADVERTISED_HOST_NAME: kafka.local KAFKA_ZOOKEEPER_CONNECT: zookeeper:2181 #设置网络，名为local networks: local: driver: bridge 启动docker-compose up -d 进入容器进入kafka容器 docker exec -it kafka /bin/bash cd /opt/kafka_2.12-2.4.0/bin/ #创建topic kafka-console-producer.sh --broker-list kafka:9092 --topic test # 查看topic，localhost要改成zookeeper容器的名字 ./kafka-topics.sh --list --zookeeper zookeeper:2181 #生产者生产消息 kafka-console-producer.sh --broker-list localhost:9092 --topic test #消费topic kafka-console-consumer.sh --bootstrap-server localhost:9092 --topic test--from-beginning","categories":[{"name":"Docker","slug":"Docker","permalink":"https://changzeyan.github.io/categories/Docker/"}],"tags":[{"name":"镜像","slug":"镜像","permalink":"https://changzeyan.github.io/tags/%E9%95%9C%E5%83%8F/"}],"author":"ChangzeYan"},{"title":"Hexo 命令","slug":"Npm/npm","date":"2021-01-01T12:48:33.000Z","updated":"2021-01-01T13:15:15.504Z","comments":true,"path":"2021/01/01/npm/npm/","link":"","permalink":"https://changzeyan.github.io/2021/01/01/npm/npm/","excerpt":"","text":"重建项目依赖rm -rf node_modules && npm install --force 更新项目依赖更新后会在package.json中看到变化，但是可能会造成格式错误，提前做好package.json的备份 npm audit fix --force","categories":[{"name":"Npm","slug":"Npm","permalink":"https://changzeyan.github.io/categories/Npm/"}],"tags":[{"name":"hexo","slug":"hexo","permalink":"https://changzeyan.github.io/tags/hexo/"}],"author":"ChangzeYan"},{"title":"Java集合框架","slug":"Java/Java集合框架/Java集合框架","date":"2020-12-19T12:24:04.000Z","updated":"2020-12-19T14:55:42.147Z","comments":true,"path":"2020/12/19/java/java-ji-he-kuang-jia/java-ji-he-kuang-jia/","link":"","permalink":"https://changzeyan.github.io/2020/12/19/java/java-ji-he-kuang-jia/java-ji-he-kuang-jia/","excerpt":"","text":"数组和集合的区别 数组能存放基本数据类型和对象，而集合类存放的都是对象，集合类不能存放基本数据类型。数组和集合存放的对象皆为对象的引用地址。Java集合中实际存放的只是对象的引用，每个集合元素都是一个引用变量，实际内容都放在堆内存或者方法区里。 // 数组能存放对象和基本数据类型 int[] nums=new int[10]; List[] listNums=new List[10]; // 集合只能存放引用数据类型 List&lt;Integer>list=new LinkedList&lt;>(); 数组大小固定无法动态改变，集合类容量动态改变。 数组无法判断其中实际存有多少元素，length只告诉了数组的容量，而集合的size()可以确切知道元素的个数 集合有多种实现方式和不同适用场合，不像数组仅采用顺序表方式 集合以类的形式存在，具有封装、继承、多态等类的特性，通过简单的方法和属性即可实现各种复杂操作，大大提高了软件的开发效率，而数组不具备这种特征 Java集合框架图椭圆为接口，方形为类，实线为继承，虚线为实现：","categories":[{"name":"Java","slug":"Java","permalink":"https://changzeyan.github.io/categories/Java/"}],"tags":[{"name":"Collection","slug":"Collection","permalink":"https://changzeyan.github.io/tags/Collection/"}],"author":"ChangzeYan"},{"title":"Python-import","slug":"Python/Python语法/Python-import","date":"2020-12-17T13:45:46.000Z","updated":"2021-01-26T10:59:35.983Z","comments":true,"path":"2020/12/17/python/python-yu-fa/python-import/","link":"","permalink":"https://changzeyan.github.io/2020/12/17/python/python-yu-fa/python-import/","excerpt":"","text":"同一包内import问题分两种情况 如果你是自己手动建的文件夹，你可以直接import 如果你是用pycharm的新建python package，你新建的目录下就会有一个init.py文件 Trie.py文件与init.py文件在同一目录NER下，在init.py中importTrie.py： '''__init__.py ''' from NER.Trie import Trie_Ope 如果仍不能导入，在导包的前面加入这样一段代码: import os, sys current_dir = os.path.abspath(os.path.dirname(__file__)) sys.path.append(current_dir) 这样导入在部署的时候可能出错，找不到 module NER，解决：将init.py文件改成其他的名称，这时这个文件夹就不是python package了，然后右键文件夹选择 mark as Sources root，然后导入： from Trie import Trie_Ope","categories":[{"name":"Python","slug":"Python","permalink":"https://changzeyan.github.io/categories/Python/"}],"tags":[{"name":"语法","slug":"语法","permalink":"https://changzeyan.github.io/tags/%E8%AF%AD%E6%B3%95/"}],"author":"ChangzeYan"},{"title":"字典树","slug":"leetcode/tree/字典树","date":"2020-12-17T13:04:44.000Z","updated":"2020-12-17T13:38:21.234Z","comments":true,"path":"2020/12/17/leetcode/tree/zi-dian-shu/","link":"","permalink":"https://changzeyan.github.io/2020/12/17/leetcode/tree/zi-dian-shu/","excerpt":"","text":"字典树又称前缀树，实现一个 Trie (前缀树)，包含 insert, search, 和 startsWith 这三个操作。 public class T208Trie &amp;#123; class TrieNode&amp;#123; TrieNode []nodes; boolean isLeaf; int id; public TrieNode()&amp;#123; nodes=new TrieNode[26]; isLeaf=false; id=0; &amp;#125; &amp;#125; private TrieNode root; public T208Trie() &amp;#123; root=new TrieNode(); &amp;#125; /** Inserts a word into the trie. */ public void insert(String word) &amp;#123; TrieNode tmpRoot=root; int len=word.length(); for (int i = 0; i &lt; len; i++) &amp;#123; char c=word.charAt(i); if(tmpRoot.nodes[c-'a']==null)&amp;#123; tmpRoot.nodes[c-'a']=new TrieNode(); &amp;#125; tmpRoot=tmpRoot.nodes[c-'a']; &amp;#125; tmpRoot.isLeaf=true; &amp;#125; /** Returns if the word is in the trie. */ public boolean search(String word) &amp;#123; TrieNode tmpRoot=root; int len=word.length(); for (int i = 0; i &lt; len; i++) &amp;#123; char c=word.charAt(i); if(tmpRoot.nodes[c-'a']==null)return false; tmpRoot=tmpRoot.nodes[c-'a']; &amp;#125; return tmpRoot.isLeaf; &amp;#125; public boolean startsWith(String prefix) &amp;#123; TrieNode tmpRoot=root; int len=prefix.length(); for (int i = 0; i &lt; len; i++) &amp;#123; char c=prefix.charAt(i); if(tmpRoot.nodes[c-'a']==null)return false; tmpRoot=tmpRoot.nodes[c-'a']; &amp;#125; return true; &amp;#125; public static void main(String[] args) &amp;#123; T208Trie t208Trie=new T208Trie(); t208Trie.insert(\"hello\"); System.out.println(t208Trie.search(\"hell\")); // false System.out.println(t208Trie.search(\"helloa\")); // false &amp;#125; &amp;#125;","categories":[{"name":"Leetcode","slug":"Leetcode","permalink":"https://changzeyan.github.io/categories/Leetcode/"}],"tags":[{"name":"Tree","slug":"Tree","permalink":"https://changzeyan.github.io/tags/Tree/"}],"author":"ChangzeYan"},{"title":"文本相似度","slug":"Python/NLP/文本相似度","date":"2020-12-17T12:30:46.000Z","updated":"2020-12-17T12:43:57.386Z","comments":true,"path":"2020/12/17/python/nlp/wen-ben-xiang-si-du/","link":"","permalink":"https://changzeyan.github.io/2020/12/17/python/nlp/wen-ben-xiang-si-du/","excerpt":"","text":"词汇语义相似度基于word_net语义相似度计算参考：WordNet介绍及相似度计算 获取单词的所有含义： print(wn.synsets(\"dog\")) >>>[Synset('dog.n.01'), Synset('frump.n.01'), Synset('dog.n.03'), Synset('cad.n.01'), Synset('frank.n.02'), Synset('pawl.n.01'), Synset('andiron.n.01'), Synset('chase.v.01')] 计算语义相似度： dog = wn.synset('dog.n.01') cat = wn.synset('cat.n.01') # 当dog词性为'dog.n.01'与'cat.n.01'的语义相似度 similar = dog.path_similarity(cat) print(similar) >>>0.2 字面相似度FuzzyWuzzyFuzzyWuzzy是字符串模糊匹配工具 安装pip install fuzzywuzzy 使用from fuzzywuzzy import fuzz from fuzzywuzzy import process # 简单匹配 fuzz.ratio(\"this is a test\", \"this is a test!\") >>> 97 # 非完全匹配（Partial Ratio） fuzz.partial_ratio(\"this is a test\", \"this is a test!\") >>> 100 # 忽略顺序匹配（Token Sort Ratio） fuzz.ratio(\"fuzzy wuzzy was a bear\", \"wuzzy fuzzy was a bear\") >>> 91 fuzz.token_sort_ratio(\"fuzzy wuzzy was a bear\", \"wuzzy fuzzy was a bear\") >>> 100 # 去重子集匹配（Token Set Ratio） fuzz.token_sort_ratio(\"fuzzy was a bear\", \"fuzzy fuzzy was a bear\") >>> 84 fuzz.token_set_ratio(\"fuzzy was a bear\", \"fuzzy fuzzy was a bear\") >>> 100 # 从候选字符串中选出最相似的字符串 choices = [\"Atlanta Falcons\", \"New York Jets\", \"New York Giants\", \"Dallas Cowboys\"] process.extract(\"new york jets\", choices, limit=2) >>> [('New York Jets', 100), ('New York Giants', 78)] process.extractOne(\"cowboys\", choices) >>> (\"Dallas Cowboys\", 90)","categories":[{"name":"Python","slug":"Python","permalink":"https://changzeyan.github.io/categories/Python/"}],"tags":[{"name":"NLP","slug":"NLP","permalink":"https://changzeyan.github.io/tags/NLP/"}],"author":"ChangzeYan"},{"title":"Python-操作mongo","slug":"Python/Python语法/Python操作mongo","date":"2020-12-16T14:10:04.000Z","updated":"2021-03-13T11:47:12.434Z","comments":true,"path":"2020/12/16/python/python-yu-fa/python-cao-zuo-mongo/","link":"","permalink":"https://changzeyan.github.io/2020/12/16/python/python-yu-fa/python-cao-zuo-mongo/","excerpt":"","text":"安装依赖pip install pymongo 获取连接from pymongo import MongoClient # 无密码： mongo_client = MongoClient(host='localhost', port=27017) # 使用管理员的用户名和密码 myclient = pymongo.MongoClient('mongodb://root:123456@localhost:27017/') 使用数据库密码： mongo_client = MongoClient(host='ip', port=34843) # 数据库名 db = mongo_client.my_mongodb db.authenticate('username', 'xxxxx') # collection名称 collection = db.student # 打印前3条数据 for document in collection.find().limit(3): print(document) 插入json_dict = json.loads(json_str) //将json字符串转成字典 mongo_collection.insert_one(json_dict) 加载mongo数据到pandasfrom pymongo import * import json import pandas as pd mongo_client = MongoClient(host='xxx', port=xxx) db = mongo_client.db_name db.authenticate('username', 'pwd') collection = db.student data = pd.DataFrame(list(collection.find())) print(data)","categories":[{"name":"Python","slug":"Python","permalink":"https://changzeyan.github.io/categories/Python/"}],"tags":[{"name":"Python-Mongo","slug":"Python-Mongo","permalink":"https://changzeyan.github.io/tags/Python-Mongo/"}],"author":"ChangzeYan"},{"title":"Docker命令","slug":"Docker/Docker命令","date":"2020-12-16T13:02:03.000Z","updated":"2021-06-06T10:52:33.460Z","comments":true,"path":"2020/12/16/docker/docker-ming-ling/","link":"","permalink":"https://changzeyan.github.io/2020/12/16/docker/docker-ming-ling/","excerpt":"","text":"# 下载镜像 docker pull 镜像名 # 查看镜像 docker images # 删除镜像 docker rmi -f （强制删除参数） 镜像名/id 运行容器： docker run [OPTIONS] IMAGE [COMMAND] [ARG...] 参数：OPTIONS说明： -a stdin: 指定标准输入输出内容类型，可选 STDIN/STDOUT/STDERR 三项； -d: 后台运行容器，并返回容器ID； -i: 以交互模式运行容器，通常与 -t 同时使用； -t: 为容器重新分配一个伪输入终端，通常与 -i 同时使用； -P: 随机端口映射，容器内部端口随机映射到主机的高端口 -p: 指定端口映射，格式为：主机(宿主)端口:容器端口 --name=\"nginx-lb\": 为容器指定一个名称；名称是唯一的，不可重名 --dns 8.8.8.8: 指定容器使用的DNS服务器，默认和宿主一致； --dns-search example.com: 指定容器DNS搜索域名，默认和宿主一致； -h \"mars\": 指定容器的hostname； -e username=\"ritchie\": 设置环境变量； --env-file=[]: 从指定文件读入环境变量； --cpuset=\"0-2\" or --cpuset=\"0,1,2\": 绑定容器到指定CPU运行； -m :设置容器使用内存最大值； --net=\"bridge\": 指定容器的网络连接类型，支持 bridge/host/none/container: 四种类型； --link=[]: 添加链接到另一个容器； --expose=[]: 开放一个端口或一组端口； --volume , -v: 绑定一个卷 --rm：--rm选项不能与-d同时使用，在容器退出后，自动执行docker rm -v 查看正在运行的容器： docker ps 已停止但仍存在的容器 docker ps -a 进入容器： docker exec -it 容器id /bin/bash 退出容器（容器不会停止） exit # 删除容器 docker rm 容器id或容器name # 强制删除容器db01、db02 docker rm -f db01 db02 查看容器日志docker logs [options] 容器名 # 打印容器mytest应用后10行的内容： docker logs --tail=\"10\" mytest 名字 默认值 描述 –details 显示提供给日志的额外细节 –follow或-f 按日志输出 –since 从某个时间开始显示，例如2013-01-02T13:23:37 –tail all 从日志末尾多少行开始显示 –timestamps或-t 显示时间戳 –until 打印某个时间以前的日志，例如 2013-01-02T13:23:37","categories":[{"name":"Docker","slug":"Docker","permalink":"https://changzeyan.github.io/categories/Docker/"}],"tags":[{"name":"命令","slug":"命令","permalink":"https://changzeyan.github.io/tags/%E5%91%BD%E4%BB%A4/"}],"author":"ChangzeYan"},{"title":"Linux命令","slug":"Linux/命令/Linux命令","date":"2020-12-16T12:06:32.000Z","updated":"2021-01-06T12:35:12.125Z","comments":true,"path":"2020/12/16/linux/ming-ling/linux-ming-ling/","link":"","permalink":"https://changzeyan.github.io/2020/12/16/linux/ming-ling/linux-ming-ling/","excerpt":"","text":"文件vi命令模式shift+:进入命令模式，在冒号后面写命令。 查找/输入要搜索的字符串或者字符，然后回车 （从前往后找） 按下n找下一个匹配项 按下N找上一个匹配项 ?要搜索的字符串或者字符 （从后往前找） 命令模式下输入:noh 退出查找高亮显示 批量替换文件内全部替换： %s#abc#def#g（用def替换文件中所有的abc） 文件内局部替换：把10行到50行内的“abc”全部替换成“def” 10,50s#abc#def#g（如文件内有#，可用/替换,:%s/abc/def/g） 以上命令如果在g后面再加上c，则会在替换之前显示提示符给用户确认（conform）是否需要替换。 比如： :%s#linuxidc.com#linuxidc.net#gc 防火墙#查看状态 firewall-cmd --state # 开启防火墙 systemctl start firewalld.service # 关闭防火墙 systemctl stop firewalld.service # 重启 firewall-cmd --reload #禁止firewall开机启动 systemctl disable firewalld.service #开机启用 systemctl enable firewalld","categories":[{"name":"Linux","slug":"Linux","permalink":"https://changzeyan.github.io/categories/Linux/"}],"tags":[{"name":"命令","slug":"命令","permalink":"https://changzeyan.github.io/tags/%E5%91%BD%E4%BB%A4/"}],"author":"ChangzeYan"},{"title":"部署Flask应用到Docker","slug":"Docker/部署flask应用到docker","date":"2020-12-16T05:04:27.000Z","updated":"2021-01-27T02:04:26.430Z","comments":true,"path":"2020/12/16/docker/bu-shu-flask-ying-yong-dao-docker/","link":"","permalink":"https://changzeyan.github.io/2020/12/16/docker/bu-shu-flask-ying-yong-dao-docker/","excerpt":"","text":"导出与项目有关的依赖安装pipreqspip install pipreqs 导出项目依赖包进入到项目根目录，如果用conda装的python，需要切换到项目的python环境： activate python36 然后执行： pipreqs ./ 成功后在项目根目录下生成requirements.txt文件。 如果报下面错误： 按照路径提示，修改pipreqs.py文件：将第74行中的 encoding=encoding 改为： encoding='utf-8' 再次执行 pipreqs ./ 新环境下安装 pip install -r requirements.txt 编写Dockerfile项目目录结构： D:. │- Dockerfile │- requirements.txt │- nltk_data └─NER key_words.txt main.py __init__.py Dockerfile： FROM python:3.6 # 暴露5001端口 EXPOSE 5001 # 将NER目录下（不包括NER目录）所有内容复制到 /usr/src/app目录下 ADD ./NER /usr/src/app # 将nltk所需的词典加入到容器的/usr/local/lib/nltk_data目录下 ADD ./nltk_data /usr/local/lib/nltk_data # WORKDIR设置将要安装应用程序的默认目录,在Dockerfile中的任何剩余命令执行以及运行容器时，其当前目录都会为这个默认目录 WORKDIR /usr/src/app # COPY将文件从你的机器复制到容器文件系统，后面的点就代表上面设置的目录 COPY requirements.txt . # 安装依赖 RUN pip install -r ./requirements.txt -i http://mirrors.aliyun.com/pypi/simple/ --trusted-host mirrors.aliyun.com # 启动应用 CMD [\"python\",\"/usr/src/app/main.py\"] copy和add的区别COPY指令和ADD指令都可以将主机上的资源复制或加入到容器镜像中，COPY指令和ADD指令的唯一区别在于是否支持从远程URL获取资源。COPY指令只能从执行docker build所在的主机上读取资源并复制到镜像中。而ADD指令还支持通过URL从远程服务器读取资源并复制到镜像中。 构建镜像将项目上传到docker服务器，进入工程目录，执行： 注意：镜像名不能有大写字母 # 最后还有一个点 docker build -t org_struct_pre:latest . # 如果远程开启了远程访问，在本地可以部署，不用将项目上传至服务器，执行： docker -H IP:2375 build -t org_struct_pre:latest . 运行容器： docker run -itd -p 5001:5001 --name org_struct_pre（容器名） org_struct_pre(镜像名) 进入容器： docker exec -it 7a31796e9cb2 /bin/bash 进入到/usr/local/lib目录，可以看到所有词典。可以正常使用nltk：","categories":[{"name":"Docker","slug":"Docker","permalink":"https://changzeyan.github.io/categories/Docker/"}],"tags":[{"name":"Flask","slug":"Flask","permalink":"https://changzeyan.github.io/tags/Flask/"},{"name":"Python","slug":"Python","permalink":"https://changzeyan.github.io/tags/Python/"}],"author":"ChangzeYan"},{"title":"Python-函数","slug":"Python/Python语法/函数","date":"2020-12-16T02:46:54.000Z","updated":"2020-12-18T08:27:17.880Z","comments":true,"path":"2020/12/16/python/python-yu-fa/han-shu/","link":"","permalink":"https://changzeyan.github.io/2020/12/16/python/python-yu-fa/han-shu/","excerpt":"","text":"参数函数参数中 *args 和 **kwargs 都是传参的方式，区别如下： *args 的返回值是一个元组，准确的说是将传入的参数中不确定的参数以元组的形式保存下来 **kwargs的返回值是一个字典，即，传参时必须以确定的键值对来传入，及以键值对保存下来，用字典方式获取 def test1(x, *args): print(\"x: \", x) print('args: ', args) return def test2(x, **kwargs): print(\"x: \", x) print('kwargs: ', kwargs) return if __name__ == '__main__': test1(1) test1(1, 2, 3, 4) test2(5) test2(1, a=1, b=2, c=3) 查看一个对象的方法dir([1,2])","categories":[{"name":"Python","slug":"Python","permalink":"https://changzeyan.github.io/categories/Python/"}],"tags":[{"name":"语法","slug":"语法","permalink":"https://changzeyan.github.io/tags/%E8%AF%AD%E6%B3%95/"}],"author":"ChangzeYan"},{"title":"Flask-GraphQL的使用","slug":"Python/web应用-flask/flask-graphql的使用","date":"2020-12-15T14:21:25.000Z","updated":"2021-02-01T11:00:26.900Z","comments":true,"path":"2020/12/15/python/web-ying-yong-flask/flask-graphql-de-shi-yong/","link":"","permalink":"https://changzeyan.github.io/2020/12/15/python/web-ying-yong-flask/flask-graphql-de-shi-yong/","excerpt":"","text":"安装flaskpip install flask 其他可能用到的包（非必须）： pip install sqlalchemy graphene flask-graphql flask-sqlalchemy graphene-sqlalchemy # MySQL pip install mysqlclient # PostgreSQL pip install psycopg2-binary hello worldfrom flask import Flask app = Flask(__name__) @app.route('/') def hello_world(): return 'Hello World!' if __name__ == '__main__': app.run() 打开浏览器访问http://127.0.0.1:5000/，浏览页面上将出现Hello World!。 Flask打开远程访问 部署到服务器(或者docker)的时候一定要打开,否则访问不到服务. if __name__ == '__main__': app = create_app() # host=0.0.0.0即打开远程访问 # 将服务端口改为4704 app.run(host='0.0.0.0',port=4704) Flask结合graphql安装：pip install graphene flask-graphql 然后编写query 和schema：from flask import Flask from graphene import ObjectType, String, Schema, Int,Field from flask_graphql import GraphQLView class User(ObjectType): id = Int() name = String() class Result(ObjectType): code = Int() msg = String() class Query(ObjectType): # this defines a Field `hello` in our Schema with a single Argument `name` hello = String(name=String(default_value=\"stranger\")) goodbye = Field(Result) # our Resolver method takes the GraphQL context (root, info) as well as # Argument (name) for the Field and returns data for the query Response # resolve需要加上固定前缀resolve_ def resolve_hello(root, info, name): return f'Hello: &#123;name&#125; !' def resolve_goodbye(root, info): return Result(1, \"success\") users = List(User, id=Int(required=True)) user = Field(User, id=Int(required=True)) def resolve_user(self, info, id): \"\"\"返回单个实例对象\"\"\" return User(id=id, name='zhangsan') def resolve_users(self, info, id): \"\"\"返回列表对象\"\"\" return [User(id=id, name='lisi')] schema = Schema(query=Query) # app = Flask(__name__) # app.add_url_rule('/graphql', view_func=GraphQLView.as_view('graphql', schema=schema, graphiql=True)) def create_app(): app = Flask(__name__) app.add_url_rule('/graphql', view_func=GraphQLView.as_view('graphql', schema=schema, graphiql=True)) # Optional, for adding batch query support (used in Apollo-Client) # app.add_url_rule('/graphql/batch', view_func=GraphQLView.as_view('graphql', schema=schema, batch=True)) @app.route(\"/\") def hello_world(): return \"Hello World!\" return app if __name__ == '__main__': app = create_app() # 默认端口号5000 app.run() # 指定端口号5001 # app.run(port=5001) 运行打开：http://127.0.0.1:5000/graphql 参数传递和获取参考： 详解Python Graphql Python使用graphene-sqlalchemy提供GraphQL接口 class NER_RESULT(ObjectType): word_list = List(String) class Query(ObjectType): # ner是方法名 # Feild表示返回一个非基本类型的对象， # 第一个参数NER_RESULT表示方法的返回值类型 # 后面的是方法需要的参数 ner = Field(NER_RESULT, text=String()) # 如果需要两个参数: # ner = Field(NER_RESULT, id=String(),text=String()) # 设置传入参数列表，args def resolve_ner(self, info, **args): text = args['text'] print(text) words = word_tokenize(text) print(words) key_words = [word.strip() for word in open(\"key_words.txt\", \"r\", encoding=\"utf-8\").readlines()] word_list = [] ner_result = NER_RESULT(word_list) return ner_result 访问： query&amp;#123; ner(text:\"When Jobs arrived back at Apple, it had a conventional structure for a company of its size and scope.\")&amp;#123; wordList &amp;#125; &amp;#125; info参数info表示请求的上下文，可以在查询语中添加context： class Query(ObjectType): hello = String(name=String(default_value=\"gaojy\", required=True)) @staticmethod def resolve_hello(root, info, name): # 通过info可获取上下文内容 print(info.context.get('company')) return f\"hello word -- &#123;name&#125;\" schema = Schema(query=Query, mutation=MyMutations) if __name__ == '__main__': query_string = '''&#123; hello(name:\"gaojiayi\") &#125;''' # 1 execute中添加context result = schema.execute(query_string, context=&#123;'company': 'baidu'&#125;) print(result.data['hello']) 返回值返回基本类型class Query(graphene.ObjectType): add = graphene.Int( description='calculate a + b then return the result.', a=graphene.Int(), b=graphene.Int()) @staticmethod def resolve_add(obj, info, a=0, b=0, **kwargs): return a + b 请求： requests.post('http://localhost:5000/graphql', json=&amp;#123; 'query': '&amp;#123;add(a: 4, b: 5)&amp;#125;' &amp;#125;) 返回列表class Query(graphene.ObjectType): rand = graphene.List( graphene.Int, description='get some random numbers from 0 to 100', count=graphene.Int(), ) @staticmethod def resolve_rand(obj, info, count=1, **kwargs): return [random.randint(0, 100) for i in range(count)] 后台运行 Python脚本nohup python -u ProductCatDataImport.py > out.log 2>&amp;1 &amp;","categories":[{"name":"Python","slug":"Python","permalink":"https://changzeyan.github.io/categories/Python/"}],"tags":[{"name":"Flask","slug":"Flask","permalink":"https://changzeyan.github.io/tags/Flask/"}],"author":"ChangzeYan"},{"title":"Python-容器","slug":"Python/Python语法/容器","date":"2020-12-15T13:01:14.000Z","updated":"2020-12-18T11:16:25.695Z","comments":true,"path":"2020/12/15/python/python-yu-fa/rong-qi/","link":"","permalink":"https://changzeyan.github.io/2020/12/15/python/python-yu-fa/rong-qi/","excerpt":"","text":"List同时遍历 list中的序号和值： for i, val in enumerate(list): print (\"序号：%s 值：%s\" % (i , val)) 两个列表合并： # 将list2的内容加到list1中 list1.extend(list2) 字典 获取字典的keySet 和valueSet # 获取所有键 dict.keys() # 获取所有值 dict.values() 添加和获取： # 如果键不存在于字典中，将会添加键并将值设为default dict.setdefault(key, default=None) # 返回指定键的值，如果值不在字典中返回default值 dict.get(key, default=None)","categories":[{"name":"Python","slug":"Python","permalink":"https://changzeyan.github.io/categories/Python/"}],"tags":[{"name":"语法","slug":"语法","permalink":"https://changzeyan.github.io/tags/%E8%AF%AD%E6%B3%95/"}],"author":"ChangzeYan"},{"title":"Python-文件操作","slug":"Python/Python语法/文件","date":"2020-12-15T12:50:20.000Z","updated":"2021-04-22T10:02:34.139Z","comments":true,"path":"2020/12/15/python/python-yu-fa/wen-jian/","link":"","permalink":"https://changzeyan.github.io/2020/12/15/python/python-yu-fa/wen-jian/","excerpt":"","text":"读文件try: # 'w'表示写，'r'表示读，'a'(append)标识追加模式 my_file=open('file.txt','w') except Exception as e: print(e) # 可以同时打开多个文件 with open('./data/code.txt', 'r', encoding='utf-8') as read_file,open('./data/write.txt', 'w', encoding='utf-8') as write_file: contents=read_file.readlines() print(contents) 一行一行地读用readline()，读取停用词表： key_words = [word.strip() for word in open(\"stop_words.txt\", \"r\", encoding=\"utf-8\").readlines()] Json从文件中加载json： with open(\"../config/record.json\",'r') as load_f: load_dict = json.load(load_f)","categories":[{"name":"Python","slug":"Python","permalink":"https://changzeyan.github.io/categories/Python/"}],"tags":[{"name":"语法","slug":"语法","permalink":"https://changzeyan.github.io/tags/%E8%AF%AD%E6%B3%95/"}],"author":"ChangzeYan"},{"title":"nlp-nltk使用","slug":"Python/NLP/nlp英文处理工具nltk","date":"2020-12-15T11:17:58.000Z","updated":"2020-12-18T12:12:34.269Z","comments":true,"path":"2020/12/15/python/nlp/nlp-ying-wen-chu-li-gong-ju-nltk/","link":"","permalink":"https://changzeyan.github.io/2020/12/15/python/nlp/nlp-ying-wen-chu-li-gong-ju-nltk/","excerpt":"","text":"Nltk安装nltkpip install nltk 然后使用的时候报错： Resource punkt not found. Please use the NLTK Downloader to obtain the resource:&gt;&gt;&gt; import nltk &gt;&gt;&gt; nltk.download(‘punkt’)使用提示代码下载词典： nltk.download('punkt') 发现下载不下来，报错：getaddrinfo failed。 方法一参考：nltk_data LookupError到：nltk_data中下载punkt包，然后解压到D:\\nltk_data\\tokenizers目录下即可。 方法二参考：离线安装nltk_data 打开Github-nltk_data，将第二个文件夹“packages”下载下来，下载Github文件夹可以用chrome插件：GitZip for github. 右键文件夹右边空白处就可以下载了 然后，将packages中的所有内容拷贝到以下目录中任意一个： - 'C:\\\\Users\\\\cunzhang/nltk_data' - 'D:\\\\Anaconda\\\\nltk_data' - 'D:\\\\Anaconda\\\\share\\\\nltk_data' - 'D:\\\\Anaconda\\\\lib\\\\nltk_data' - 'C:\\\\Users\\\\cunzhang\\\\AppData\\\\Roaming\\\\nltk_data' - 'C:\\\\nltk_data' - 'D:\\\\nltk_data' - 'E:\\\\nltk_data' linux中的目录是： Searched in: - '/home/hadoopcj/nltk_data' - '/usr/share/nltk_data' - '/usr/local/share/nltk_data' - '/usr/lib/nltk_data' - '/usr/local/lib/nltk_data' - '/home/hadoopcj/nltk_data' - '' 然后进入到”D:\\nltk_data\\tokenizers”目录，将punkt.zip解压 即可。 nltk英文分词from nltk import word_tokenize paragraph = \"When Jobs arrived back at Apple, it had a conventional structure for a company of its size and scope. It was divided into business units, each with its own P&L responsibilities.\" words = word_tokenize(paragraph) print(words) 词性标注nltk中的词性： tag mean 释义 例子 CC Coordinating conjunction 连词 and, or,but, if, while,although CD Cardinal number 数词 twenty-four, fourth, 1991,14:24 DT Determiner 限定词 the, a, some, most,every, no EX Existential there 存在量词 there, there’s FW Foreign word 外来词 dolce, ersatz, esprit, quo,maitre IN Preposition or subordinating conjunction 介词连词 on, of,at, with,by,into, under JJ Adjective 形容词 new,good, high, special, big, local JJR Adjective, comparative 比较级词语 bleaker braver breezier briefer brighter brisker JJS Adjective, superlative 最高级词语 calmest cheapest choicest classiest cleanest clearest LS List item marker 标记 A A. B B. C C. D E F First G H I J K MD Modal 情态动词 can cannot could couldn’t NN Noun, singular or mass 名词 year,home, costs, time, education NNS Noun, plural 名词复数 undergraduates scotches NNP Proper noun, singular 专有名词 Alison,Africa,April,Washington NNPS Proper noun, plural 专有名词复数 Americans Americas Amharas Amityvilles PDT Predeterminer 前限定词 all both half many POS Possessive ending 所有格标记 ’ ‘s PRP Personal pronoun 人称代词 hers herself him himself hisself PRP$ Possessive pronoun 所有格 her his mine my our ours RB Adverb 副词 occasionally unabatingly maddeningly RBR Adverb, comparative 副词比较级 further gloomier grander RBS Adverb, superlative 副词最高级 best biggest bluntest earliest RP Particle 虚词 aboard about across along apart SYM Symbol 符号 % &amp; ’ ” ”. ) ) TO to 词to to UH Interjection 感叹词 Goodbye Goody Gosh Wow VB Verb, base form 动词 ask assemble assess VBD Verb, past tense 动词过去式 dipped pleaded swiped VBG Verb, gerund or present participle 动词现在分词 telegraphing stirring focusing VBN Verb, past participle 动词过去分词 multihulled dilapidated aerosolized VBP Verb, non-3rd person singular present 动词现在式非第三人称时态 predominate wrap resort sue VBZ Verb, 3rd person singular present 动词现在式第三人称时态 bases reconstructs marks WDT Wh-determiner Wh限定词 who,which,when,what,where,how WP Wh-pronoun WH代词 that what whatever WP$ Possessive wh-pronoun WH代词所有格 whose WRB Wh-adverb WH副词 # 分词后的词列表 paragraph='When Jobs arrived back at Apple, it had a conventional structure for a company of its size and scope. It was divided into business units,' words = word_tokenize(paragraph) # 词性标注 pos_tag = nltk.pos_tag(words) print(pos_tag) 获取一个词的词性也得用列表： t=nltk.pos_tag(['news']) print(t) Nltk的语料库语料库在D:\\nltk_data\\corpora下： 参考：NLTK文本语料库 古腾堡语料库：gutenberg，包含古腾堡项目电子文本档案的一小部分文本。该项目目前大约有36000本免费的电子图书。 网络聊天语料库：webtext、nps_chat；这部分代表的是非正式的语言，包括Firefox交流论坛、在纽约无意听到的对话、《加勒比海盗》电影剧本。个人广告以及葡萄酒的评论。 布朗语料库：brown；布朗语意库是第一个百万词集的英语电子语料库，有布朗大学于1961年创建，包含500多个不同来源的文本，按照文本类型，如新闻、社评等分类。布朗语料库是一个研究文体之间系统性差异的资源。 路透社语料库：reuters；路透社语料库包括10788个新闻文档，共计130万字。这些文档分成了90个主题，按照‘训练’和‘测试’分为两组。因此，编号为‘test/14826’的文档属于测试组。这样分割是为了方便运用训练和测试算法的自动检验文档的主题。 就职演说语料库：inaugural；是55个文本的集合，每个文本都是一个总统的演讲。这个集合的显著特征就是时间维度。 标注文本语料库和其他语言语料库","categories":[{"name":"Python","slug":"Python","permalink":"https://changzeyan.github.io/categories/Python/"}],"tags":[{"name":"NLP","slug":"NLP","permalink":"https://changzeyan.github.io/tags/NLP/"}],"author":"ChangzeYan"},{"title":"Conda 命令","slug":"Python/Conda/conda命令","date":"2020-12-15T05:24:09.000Z","updated":"2021-09-06T01:57:07.014Z","comments":true,"path":"2020/12/15/python/conda/conda-ming-ling/","link":"","permalink":"https://changzeyan.github.io/2020/12/15/python/conda/conda-ming-ling/","excerpt":"","text":"安装包指定下载源pip install xxx Could not fetch URL https://pypi.tuna.tsinghua.edu.cn/simple/pipenv/解决，常用的镜像地址有： # 阿里云 http://mirrors.aliyun.com/pypi/simple/ # 中国科技大学 https://pypi.mirrors.ustc.edu.cn/simple/ # 豆瓣 http://pypi.douban.com/simple/ # 清华大学 https://pypi.tuna.tsinghua.edu.cn/simple/ # 中国科学技术大学 http://pypi.mirrors.ustc.edu.cn/simple/ 安装时指定下载源： pip install xxx -i http://mirrors.aliyun.com/pypi/simple/ --trusted-host mirrors.aliyun.com 指定安装包的版本# 安装 conda install numpy=1.9.3 # 更新 conda update numpy=1.9.3 查看虚拟环境conda info --envs 创建python环境: 先在conda中创建一个名为python2的环境，并下载对应版本python2.7 conda create --name python27 python=2.7 或 conda create -n python36 python=3.6.6 conda create -n yourenvname python=x.x anaconda (还会创建与python版本有关的anaconda打包库) 激活（切换）python环境 activate yourenvname 退出虚拟环境：deactivate myenv 删除虚拟环境 conda remove -n yourenvname --all","categories":[{"name":"Python","slug":"Python","permalink":"https://changzeyan.github.io/categories/Python/"}],"tags":[{"name":"Conda","slug":"Conda","permalink":"https://changzeyan.github.io/tags/Conda/"}],"author":"ChangzeYan"},{"title":"Hithesis 工大论文模板","slug":"write/Latex/Hithesis/Hithesis工大论文模板","date":"2020-12-14T11:58:50.000Z","updated":"2021-06-05T06:24:58.480Z","comments":true,"path":"2020/12/14/write/latex/hithesis/hithesis-gong-da-lun-wen-mo-ban/","link":"","permalink":"https://changzeyan.github.io/2020/12/14/write/latex/hithesis/hithesis-gong-da-lun-wen-mo-ban/","excerpt":"","text":"中期报告hithesis模板下载地址：hithesis 将zip包下载解压，根目录为： 生成样式文件然后在根目录下执行（在github项目介绍中）： # windows: lualatex hithesis.ins # mac/linux latex hithesis.ins # make make cls 编译生成好格式后，进入到示例文件夹中 examples ├── hitart │ ├── reportplus %深圳校区博士中期报告 │ └── reports %除去深圳校区博士中期报告的一校三区本硕博开题、中期报告 └── hitbook ├── chinese %一校三区本硕博毕业论文以及博后出站报告 └── english %一校三区本硕博英文版毕业论文 在hitart/reports目录下执行： xelatex -shell-escape report.tex bibtex report xelatex -shell-escape report.tex xelatex -shell-escape report.tex 或者用vscode打开该目录，直接执行。 最后生成的开题中期报告格式不太正确： 因此换用hithesis-alpha。 windows下使用docker第一步，下载tinytex-hithesis镜像， docker pull dustincys/tinytex-hithesis:latest 第二步，在hithesis根目录下执行抽取格式 docker run --rm -i -v $(pwd):/home/runner dustincys/tinytex-hithesis:latest latex hithesis.ins Windows下改为： docker run --rm -i -v D:\\Document\\Hit\\HitThesis\\Thesis\\hithesis-newVersion-master\\hithesis:/home/runner dustincys/tinytex-hithesis:latest latex hithesis.ins -v 冒号前面是本地项目路径，后面是容器内路径 第三步，在hithesis毕业论文文件夹hitbook或报告文件夹report下执行以下命令进行编译 docker run --rm -i -v $(pwd):/home/runner dustincys/tinytex-hithesis:latest make thesis Windows下改为： docker run --rm -i -v D:\\Document\\Hit\\HitThesis\\Thesis\\hithesis-newVersion-master\\hithesis\\examples\\hitbook\\chinese:/home/runner dustincys/tinytex-hithesis:latest make thesis docker run --rm -i -v $(pwd):/home/runner dustincys/tinytex-hithesis:latest make report 或者编译文档 docker run --rm -i -v $(pwd):/home/runner dustincys/tinytex-hithesis:latest make doc hithesis-alpha下载地址：hithesis-alpha 生成样式文件同hithesis一样，在根目录下运行： # windows: lualatex hithesis.ins # mac/linux latex hithesis.ins 编译用vscode直接打开根目录，编辑main.tex，修改documentclass的参数： \\documentclass[newtxmath=true,newgeometry=two,capcenterlast=true, subcapcenterlast=true,openright=false,absupper=true, type=master,stage=zhongqi,campus=harbin]&amp;#123;hithesis&amp;#125; 生成的样式如下： 学位论文使用 hithesis的example/hitbook即可。在thesis.tex中修改： \\documentclass[fontset=fandol,type=master,campus=harbin]&amp;#123;hithesisbook&amp;#125; 样式以下命令打开官方文档： texdoc hithesis 参考文献将“文献[x]”中的[x]表示为正常的文本，而不是引用格式上标： \\inlinecite&amp;#123;key&amp;#125; 直接用vscode 编译时有时不会产生参考文献，用下面命令编译一遍即可： xelatex -shell-escape thesis.tex bibtex thesis xelatex -shell-escape thesis.tex xelatex -shell-escape thesis.tex 列表更改标号样式# 使用方括号阿拉伯数字标号 \\begin&amp;#123;enumerate&amp;#125;[label=&amp;#123;[\\arabic*]&amp;#125;] \\item xxxxx %[1] xxxxx \\item yyyyyy %[2] yyyyyy \\item zzzzz %[3] zzzzz \\end&amp;#123;enumerate&amp;#125; # 使用圆括号阿拉伯数字标号 \\begin&amp;#123;enumerate&amp;#125;[label=&amp;#123;(\\arabic*)&amp;#125;] \\item xxxxx %(1) xxxxx \\item yyyyyy %(2) yyyyyy \\item zzzzz %(3) zzzzz \\end&amp;#123;enumerate&amp;#125; 在\\begin{enumerate}[label={[\\arabic*]}]后面跟\\setlength{\\itemsep}{0pt}可以设置当前列表环境里item条目之间的间距。 \\arabic可以替换为\\roman、\\Roman、\\Alph 或 \\alph来表示小写罗马数字、大写罗马数字、大写字母编号 或 小写字母编号。 目录设置三级目录默认的目录只显示两级，在main.tex中设置显示三级目录，在\\document{}后添加\\setcounter{tocdepth}{3}： \\documentclass[newtxmath=true,newgeometry=two,capcenterlast=true,subcapcenterlast=true,openright=false,absupper=true,type=master,stage=zhongqi,campus=harbin]&#123;hithesis&#125; % 设置三级目录 \\setcounter&#123;tocdepth&#125;&#123;3&#125; 去掉目录中摘要和第一章之间的空行参考：issues-目录格式问题 在主文件中中设置： \\documentclass[fontset=fandol,type=master,campus=harbin,tocblank=false]&#123;hithesisbook&#125; % tocblank=true|false % 含义：目录中第一章之前，是否加一行空白。缺省值为true。 去掉图表标题中的冒号当增加了一些自定义设置后，原来的图表标题可能会发生变化，可以按照下面修改： \\usepackage&#123;caption&#125; % 设置表格 \\captionsetup[table]&#123;labelsep=space&#125; % 设置图片，skip表示图片和标题之间距离 \\captionsetup[figure]&#123;font=small,skip=0pt&#125; % 全部设置 \\captionsetup&#123;font=&#123;small&#125;,labelsep=space&#125; 算法修改输入输出样式中文latex模式下，更改Input为输入，更改Output为输出的方法：在算法内部插入： \\SetKwInOut&#123;KIN&#125;&#123;输入&#125; \\SetKwInOut&#123;KOUT&#125;&#123;输出&#125; 例如： \\begin&#123;algorithm&#125;[!ht] \\SetKwInOut&#123;KIN&#125;&#123;输入&#125; \\SetKwInOut&#123;KOUT&#125;&#123;输出&#125; \\caption&#123;xxxx方法&#125; \\label&#123;department_fun&#125; \\KIN&#123;data,s,dic&#125; \\KOUT&#123;vec&#125; \\lIf&#123;s 为空串&#125;&#123;直接返回&#125; len$\\gets$ s.length()\\; ss$\\gets$s.toCharArray() \\; dp$\\gets$ new boolean[len][len] \\; ans$\\gets$ &quot;&quot;+ss[0] \\; maxLen$\\gets$1 \\; \\For&#123;i from 0 To len&#125;&#123; dp[i][i]$\\gets$true \\; &#125; \\end&#123;algorithm&#125; 基本语法 代码 含义 \\; 在行末添加分号，并自动换行 \\caption{} 插入标题 \\KwData{输入信息} 效果：“Data:输入信息” \\KwIn{输入信息} 效果：“Input:输入信息” \\KwOut{输出信息} 效果：“Output:输出信息” \\KwResult{输出信息} 效果：“Result:输出信息” \\tcc{注释} 效果：/* 注释*/ \\tcp{注释} 效果：// 注释","categories":[{"name":"Latex","slug":"Latex","permalink":"https://changzeyan.github.io/categories/Latex/"}],"tags":[{"name":"Hithesis","slug":"Hithesis","permalink":"https://changzeyan.github.io/tags/Hithesis/"}],"author":"ChangzeYan"},{"title":"Graphql的使用","slug":"Graphql/Graphql的使用","date":"2020-12-10T12:20:08.000Z","updated":"2020-12-10T14:23:54.169Z","comments":true,"path":"2020/12/10/graphql/graphql-de-shi-yong/","link":"","permalink":"https://changzeyan.github.io/2020/12/10/graphql/graphql-de-shi-yong/","excerpt":"","text":"添加pom依赖&lt;dependency> &lt;groupId>com.graphql-java&lt;/groupId> &lt;artifactId>graphql-java-tools&lt;/artifactId> &lt;version>5.2.4&lt;/version> &lt;/dependency> &lt;dependency> &lt;groupId>org.mountcloud&lt;/groupId> &lt;artifactId>graphql-client&lt;/artifactId> &lt;version>1.1&lt;/version> &lt;/dependency> &lt;dependency> &lt;groupId>com.graphql-java&lt;/groupId> &lt;artifactId>graphiql-spring-boot-starter&lt;/artifactId> &lt;version>5.0.2&lt;/version> &lt;/dependency> &lt;dependency> &lt;groupId>com.graphql-java&lt;/groupId> &lt;artifactId>graphql-spring-boot-starter&lt;/artifactId> &lt;version>5.0.2&lt;/version> &lt;/dependency> graphiql便于调试接口和查看文档，项目启动后访问：http://ip:port/graphiql 添加Query和Type在resources根目录下新建root.graphqls文件和schema.graphqls 文件，名字不可更换 root.graphqlsroot.graphqls中用于定义接口： type Query&amp;#123; # 启动任务 startEnterpriseRelationshipAnalyse(module:String,organizationName:String,organizationUrl:String,userId:String): StartProcessResult # 获取当前正在执行的任务名称 currentTask(processInstanceId: String): ProcessCurrentTaskResult # 获取所有任务 taskList(page:Int, size:Int ): OrganizationTaskPageResult # 获取所有已经完成的任务 completedTaskList(page:Int, size:Int ):OrganizationTaskPageResult &amp;#125; 在graphqls文件中写的注释会体现在http://ip:port/graphiql 中的文档上。该文件中定义了4个接口，小括号内是接口需要传入的参数，冒号后面是接口的返回值。 Result：返回一个Result的数据类型 [AnalysisJsonResponse]，返回一个 AnalysisJsonResponse类型的列表。 ProcessCurrentTaskResult返回一个ProcessCurrentTaskResult类型 Result和 ProcessCurrentTaskResult等类型都在schema.graphqls中定义。 schema.graphqlstype Result&amp;#123; code: Int msg: String &amp;#125; type StartProcessResult &amp;#123; result: Result taskId: String processInstanceId: String &amp;#125; # 获取当前正在执行的任务名称结果 type ProcessCurrentTaskResult&amp;#123; result: Result processTaskId: String &amp;#125; type PageInfo&amp;#123; total: Int current: Int size: Int &amp;#125; type OrganizationTaskResult&amp;#123; taskId: String processCode:String processId:String userId:String organizationName: String organizationUrl: String module: String progress: String status: String createTime: String endTime: String &amp;#125; type OrganizationTaskPageResult&amp;#123; # [OrganizationTaskResult]表示 OrganizationTaskResult 类型的列表 list: [OrganizationTaskResult] pageInfo: PageInfo result: Result &amp;#125; schema中定义的类型要编写对应的Entity类，方便后面构建对象。 定义Resolver在root.graphqls中定义的接口要在resolver中实现，否则会报错。 import com.coxautodev.graphql.tools.GraphQLQueryResolver; import com.topveda.cloudactiviti.entity.*; import com.topveda.cloudactiviti.service.EnterpriseRaService; import com.topveda.cloudactiviti.service.OrganizationTaskService; import org.springframework.beans.factory.annotation.Autowired; import org.springframework.stereotype.Component; @Component public class ActivitiResolver implements GraphQLQueryResolver &amp;#123; @Autowired private EnterpriseRaService enterpriseRaService; @Autowired private OrganizationTaskService organizationTaskService; public String deploy()&amp;#123; String deploymentId=enterpriseRaService.deploy(); return deploymentId; &amp;#125; public StartProcessResult startEnterpriseRelationshipAnalyse(String module, String organizationName, String organizationUrl, String userId)&amp;#123; //.... return StartProcessResult.builder() .taskId(taskId) .processInstanceId(processInstanceId) .result(Result.builder().code(0).msg(\"success\").build()) .build(); &amp;#125; public ProcessCurrentTaskResult currentTask(String processInstanceId)&amp;#123; String currentTaskId=enterpriseRaService.getCurrentTask(processInstanceId); return ProcessCurrentTaskResult.builder() .result(Result.builder().code(0).msg(\"success\").build()) .processTaskId(currentTaskId) .build(); &amp;#125; public ProcessLastTaskResult lastFinishedTask(String processInstanceId)&amp;#123; String lastFinishedTaskId=enterpriseRaService.getLastFinishedTask(processInstanceId); return ProcessLastTaskResult.builder() .result(Result.builder().code(0).msg(\"success\").build()) .processTaskId(lastFinishedTaskId) .build(); &amp;#125; public OrganizationTaskPageResult taskList(int page,int size)&amp;#123; return organizationTaskService.getTaskListByPage(page,size); &amp;#125; // 获取所有已经完成的任务 public OrganizationTaskPageResult completedTaskList(int page,int size)&amp;#123; return organizationTaskService.getCompletedTaskListByPage(page,size); &amp;#125; &amp;#125; 调用接口运行程序，访问http://ip:port/graphiql：打开右侧的query，会看到接口文档，有接口名称，参数和返回值类型可以根据自己需要的返回值定义访问形式，上图中只返回result的msg属性（按需返回），如果需要返回result的code属性，写为： currentTask(processInstanceId:\"e00ca85a-360e-11eb-9ca6-809599575c52\")&amp;#123; result&amp;#123; msg code &amp;#125; processTaskId &amp;#125; 然后点击左上角的运行按钮即可运行接口。 返回自定义对象列表如果需要返回自定义的对象列表，以上面定义的completedTaskList为例： &amp;#123; completedTaskList(page:1,size:10)&amp;#123; list&amp;#123; taskId processCode &amp;#125; pageInfo&amp;#123; total current size &amp;#125; result&amp;#123; code &amp;#125; &amp;#125; &amp;#125;","categories":[{"name":"Graphql","slug":"Graphql","permalink":"https://changzeyan.github.io/categories/Graphql/"}],"tags":[],"author":"ChangzeYan"},{"title":"部署springboot项目到docker","slug":"Docker/部署springboot项目到docker","date":"2020-12-10T10:22:44.000Z","updated":"2020-12-10T14:20:31.156Z","comments":true,"path":"2020/12/10/docker/bu-shu-springboot-xiang-mu-dao-docker/","link":"","permalink":"https://changzeyan.github.io/2020/12/10/docker/bu-shu-springboot-xiang-mu-dao-docker/","excerpt":"","text":"idea插件部署idea中安装docker插件在setting-plugin中搜索并安装docker： 连接远程docker服务器在build，docker中添加一个连接，并填写好服务器ip和端口： 将springboot项目打包点击上面的skip test按钮，可以跳过测试： 编写DockerFileDockerFile位置与target文件夹同级目录，DockerFile中的路径是相对路径： 指定了临时文件目录为/tmp，其效果是在主机 /var/lib/docker 目录下创建了一个临时文件，并链接到容器的/tmp，ENTRYPOINT 执行项目 cloud-activiti.jar。为了缩短 Tomcat 启动时间，添加一个系统属性指向 “/dev/./urandom” 作为 Entropy Source FROM java:8 #暴露容器的9023端口 EXPOSE 9023 #将复制指定的cloud-activiti-0.0.1-SNAPSHOT.jar为容器中的cloud-activiti.jar，相当于拷贝到容器中取了个别名 ADD target/cloud-activiti-0.0.1-SNAPSHOT.jar /cloud-activiti.jar VOLUME /tmp RUN bash -c 'touch /cloud-activiti.jar' ENTRYPOINT [\"java\",\"-Djava.security.egd=file:/dev/./urandom\",\"-jar\",\"/cloud-activiti.jar\"] 部署和运行点击Edit Configuration：点击左上角加号，“+”： 选择DockerFile：选择要部署的目标docker服务器，dockerfile文件，端口号，tag等：然后点击run，即可部署到docker服务器中。 手动部署上传Dockerfile和jar包将Dockerfile和 jar包上传到docker服务器，注意dockerfile中jar包的路径，决定了Dockerfile和jar包的相对位置。 制作镜像执行下面命令， 看好，最后面有个”.”点！ docker build -t springbootdemo4docker . -t 参数是指定此镜像的tag名 启动镜像制作完成后通过docker images命令可以查看制作的镜像，然后启动： docker run -d -p 8080:8085 springbootdemo4docker -d参数是让容器后台运行-p 是做端口映射，此时将服务器中的8080端口映射到容器中的8085(项目中端口配置的是8085)端口 访问http://docker服务器ip地址:8080/","categories":[{"name":"Docker","slug":"Docker","permalink":"https://changzeyan.github.io/categories/Docker/"}],"tags":[{"name":"部署","slug":"部署","permalink":"https://changzeyan.github.io/tags/%E9%83%A8%E7%BD%B2/"}],"author":"ChangzeYan"},{"title":"windows cmd","slug":"windows/windows-cmd","date":"2020-12-08T14:31:00.000Z","updated":"2021-05-02T02:16:49.687Z","comments":true,"path":"2020/12/08/windows/windows-cmd/","link":"","permalink":"https://changzeyan.github.io/2020/12/08/windows/windows-cmd/","excerpt":"","text":"查看并解除端口占用查看占用4000端口的进程： netstat -ano|findstr \"4000\" 停止进程，PID为LISTENING后的数字） taskkill /pid \"PID\" /F 如果出现：“无法终止 PID 为 xxx 的进程”，用管理员方式打开cmd，再次终止进程。 打开防火墙端口在管理员模式下，打开2375端口，支持远程访问： netsh advfirewall firewall add rule name=\"docker_daemon\" dir=in action=allow protocol=TCP localport=2375 无法访问github能正常访问其他网站，却访问不了GitHub，怀疑是本地DNS解析出现问题。访问：fastly.net.ipaddress.com 访问：github 的ip 打开C:\\Windows\\System32\\drivers\\etc\\hosts，添加： #github 140.82.112.3 github.com 199.232.69.194 github.global.ssl.fastly.net 然后在cmd中运行（可选）： ipconfig /flushdns 将文本中的unicode 编码转换称中文参考：一条指令将文件中的unicode编码转为中文 下图是文本中所含的Unicode码：在文件所在目录cmd执行： native2ascii -reverse -encoding UTF-8 htmls1.json htmls2.json 转换后的结果：","categories":[{"name":"Windows","slug":"Windows","permalink":"https://changzeyan.github.io/categories/Windows/"}],"tags":[{"name":"cmd","slug":"cmd","permalink":"https://changzeyan.github.io/tags/cmd/"}],"author":"ChangzeYan"},{"title":"TCP和UDP协议","slug":"计算机网络/传输层/TCP和UDP协议","date":"2020-12-08T14:01:43.000Z","updated":"2021-11-19T20:26:27.337Z","comments":true,"path":"2020/12/08/ji-suan-ji-wang-luo/chuan-shu-ceng/tcp-he-udp-xie-yi/","link":"","permalink":"https://changzeyan.github.io/2020/12/08/ji-suan-ji-wang-luo/chuan-shu-ceng/tcp-he-udp-xie-yi/","excerpt":"","text":"TCP协议传输控制协议（TCP，Transmission Control Protocol）是一种面向连接的、可靠的、基于字节流的传输层通信协议。TCP特点： 面向连接 点对点，每条连接只能有两个端点 可靠交付，保证数据在传输过程中无差错、不丢失、不重复 全双工通信，连接两端都能发送和接收信息。 面向字节流。 三次握手三次握手用于建立TCP连接，需要在客户端与服务器之间交换三个TCP报文段。 建立连接的过程： 客户端A打算建立TCP连接时，向服务器B发出连接请求报文段，首部中的同步位SYN=1，选择一个初始序号x。此时，A进入【同步已发送状态】表示正尝试建立连接。SYN报文段不能携带数据，需要消耗一个序列号。 B收到连接请求报文段后，如果同意连接，向A发送确认。在报文段中将同步位SYN和ACK都置1，确认号是x+1，然后选择一个初始序号seq=y，此时B进入【同步已接收状态】。这个报文段也不能携带数据，需要消耗一个序列号。 A收到B的确认后，还要向B给出确认。确认报文的ACK置1，确认号ack=y+1，序号是x+1。ACK报文段可以携带数据，如果不携带数据则不消耗序号，下一个报文的序号仍是x+1。此时A进入已建立连接状态，当B收到A的确认后，也进入建立连接状态。 为什么要三次握手？ TCP连接是可靠的，需要确保服务器和客户端都具备接收和发送数据的能力。 第一次握手证明客户端具备发送信息的能力，第二次握手证明服务端具备接收和发送信息的能力第三次握手证明客户端具备接收信息的能力（只有接收到了信息才会向服务端发送确认信息）如果是两次就建立连接，服务端无法确认客户端是否具备接收信息的能力; 如果四次或更多的次的话，就造成了重复，前面服务端已经同意了建立连接，并且做好了连接准备，就没必要再次发送同意报文了 防止因网络堵塞造成服务器忙等，造成资源浪费的情况。 如果是两次的话，考虑这样一种情形，客户端第一次发送的连接请求因网络堵塞而没有到达服务器，当到达了超时重传时间后，客户端仍没有收到服务器的确认报文，就会发送第二次连接请求，这时服务端收到了该请求，并发送了确认信息，这时候连接建立； 过一段时间后，被网络堵塞的第一次连接请求也到达了服务端，服务器接收后就发送了确认信息，此时建立了连接并为该链接分配了资源，等待客户端发送信息，而客户端并不会处理这个连接，因为它已经通过超时重传建立了连接并处理了自己信息，所以服务端就会忙等，造成了服务端的资源浪费。 四次挥手通信结束后，通信双方都可释放连接。释放前，A、B双方都处于连接已建立状态，假设A主动关闭TCP连接。 A把final报文段首部的终止控制位FIN置1，其序号seq=u，此时A进入终止等待1状态。Final报文段即使不携带数据，也要消耗一个序号。 B收到Final报文段后发出确认，ACK置1，确认号是ack=u+1，序号是v。然后B进入关闭等待状态。此时TCP连接处于半关闭状态，即A没有数据要发送，但是B发送的数据A仍要接收，B到A方向的连接没有关闭。A收到来自B的确认后进入终止等待2状态，等待B发送连接释放报文段。 当B发送完数据之后，向A发送Final报文段，FIN置1，ACK置1，序号为w，确认号u+1。此时B进入最后确认状态。 A收到B的Final报文后，必须对此发出确认，ACK置1，确认号ack=w+1，序号是u+1。然后进入到时间等待状态，必须等待2个MSL【1个MSL后，A发送的确认到达B，再等一个MSL，保证如果B重传了Final，这个Final在1个MSL也能到达A】（MSL是最长报文段寿命，即报文段在网络中存在的最长时间）后，A才进入关闭状态。B收到确认后，也进入关闭连接状态。 为什么需要四次挥手？第三次挥手的作用是因为B发送完数据后需要通知A，否则A会一直处于等待接收B数据的状态，这样造成了资源浪费。而第四次挥手是A告诉B收到了请求的确认，如果没有这个确认，B不知道A是否收到了自己发出的请求，会一直重传该请求，所以第四次挥手也是必须的。 服务器大量出现close_wait的原因如果服务器端不执行socket的close()操作，状态就不能由close_wait迁移到last_ack，则系统中会存在很多close_wait状态的连接。 TCP拥塞避免参考-TCP拥塞避免 慢开始慢开始算法的思路就是，不要一开始就发送大量的数据，先探测一下网络的拥塞程度，也就是说由小到大逐渐增加拥塞窗口的大小。发送方让自己的发送窗口等于拥塞窗口。每经过一个传输轮次，拥塞窗口就增加一倍。为了防止拥塞窗口增长过大，还需要设置慢开始门限。 拥塞避免当拥塞窗口增大到慢开始门限时，就改为执行拥塞避免算法，此时拥塞窗口加法增大，就是线性增长，使得网络比较不容易堵塞。 无论是在慢开始阶段还是在拥塞避免阶段，只要发送方判断网络出现拥塞（其根据就是没有收到确认，虽然没有收到确认可能是其他原因的分组丢失，但是因为无法判定，所以都当做拥塞来处理），就把慢开始门限设置为出现拥塞时的发送窗口大小的一半。然后把拥塞窗口设置为1，执行慢开始算法。 快重传快重传要求接收方在收到一个失序的报文段后就立即发出重复确认（为的是使发送方及早知道有报文段没有到达对方）而不要等到自己发送数据时捎带确认。快重传算法规定，发送方只要一连收到三个重复确认就应当立即重传对方尚未收到的报文段，而不必继续等待设置的重传计时器时间到期。立即重传不会出现超时，发送发也不会误以为出现了网络拥塞。 快恢复快重传配合使用的还有快恢复算法，当发送方连续收到三个重复确认时，知道丢失了个别报文段，于是不启动慢开始（不把拥塞窗口置为1），而是执行快恢复，把慢开始门限设置为当前拥塞窗口的一半，再将拥塞窗口设置为门限值，然后开始执行拥塞避免。 如何保证可靠传输 TCP 给发送的每一个包进行编号，接收方对数据包进行排序，把有序数据传送给应用层。 校验和： TCP 将保持它首部和数据的检验和。这是一个端到端的检验和，目的是检测数据在传输过程中的任何变化。如果收到段的检验和有差错，TCP 将丢弃这个报文段和不确认收到此报文段。 TCP 的接收端会丢弃重复的数据。 流量控制： TCP 连接的每一方都有固定大小的缓冲空间，TCP的接收端只允许发送端发送接收端缓冲区能接纳的数据。当接收方来不及处理发送方的数据，能提示发送方降低发送的速率，防止包丢失。TCP 使用的流量控制协议是可变大小的滑动窗口协议。 （TCP 利用滑动窗口实现流量控制） 拥塞控制： 当网络拥塞时，减少数据的发送。 停止等待协议: 也是为了实现可靠传输的，它的基本原理就是每发完一个分组就- 停止发送，等待对方确认。在收到确认后再发下一个分组。 超时重传： 当 TCP 发出一个段后，它启动一个定时器，等待目的端确认收到这个报文段。如果不能及时收到一个确认，将重发这个报文段。 流量控制TCP采用滑动窗口实现流量控制，以控制发送方发送速率，保证接收方来得及接收。接收方发送的确认报文中的窗口字段可以用来控制发送方窗口大小，从而影响发送方的发送速率。将窗口字段设置为 0，则发送方不能发送数据。 TCP粘包问题参考-TCP粘包问题TCP粘包就是指发送方发送的若干包数据到达接收方时粘成了一包，从接收缓冲区来看，后一包数据的头紧接着前一包数据的尾，出现粘包的原因是多方面的，可能是来自发送方，也可能是来自接收方。 发送方造成的粘包 &emsp;&emsp;TCP默认使用Nagle算法（主要作用：减少网络中报文段的数量），而Nagle算法主要做两件事：第一是只有上一个分组得到确认，才会发送下一个分组；第二是收集多个小分组，在一个确认到来时一起发送。2. 接收方造成的粘包 &emsp;&emsp;TCP接收到数据包时，并不会马上交到应用层进行处理，或者说应用层并不会立即处理。TCP将接收到的数据包保存在接收缓存里，然后应用程序主动从缓存读取收到的分组。这样一来，如果TCP接收数据包到缓存的速度大于应用程序从缓存中读取数据包的速度，多个包就会被缓存，应用程序就有可能读取到多个首尾相接粘到一起的包。","categories":[{"name":"计算机网络","slug":"计算机网络","permalink":"https://changzeyan.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"}],"tags":[],"author":"ChangzeYan"},{"title":"OSI七层协议","slug":"计算机网络/OSI七层协议","date":"2020-12-08T13:16:05.000Z","updated":"2021-11-19T20:27:01.476Z","comments":true,"path":"2020/12/08/ji-suan-ji-wang-luo/osi-qi-ceng-xie-yi/","link":"","permalink":"https://changzeyan.github.io/2020/12/08/ji-suan-ji-wang-luo/osi-qi-ceng-xie-yi/","excerpt":"","text":"应用层该层为用户提供常用的应用程序，每个网络应用都对应着不同的协议，例如：FTP负责文件传输，DNS域名协议，SMTP邮件发送协议、POP3邮件接收协议（IMAP邮件接收协议，与POP3的区别在于 POP3 中邮件由客户端管理，而在 IMAP 中邮件由服务器管理）等 FTP协议FTP（File Transfer Protocol，文件传输协议） 是 TCP/IP 协议组中的协议之一。FTP协议包括两个组成部分，其一为FTP服务器，其二为FTP客户端。其中FTP服务器用来存储文件，用户可以使用FTP客户端通过FTP协议访问位于FTP服务器上的资源。默认情况下FTP协议使用TCP端口中的 20和21这两个端口，其中20用于传输数据，21用于传输控制信息。 表示层表示层：确保一个系统的应用层发送的消息可以被另一个系统的应用层读取，编码转换，数据解析，管理数据的加密解密、转换翻译、压缩和解压缩，最小传输单位：表示协议数据单元 会话层会话层：在网络中的两节点建立，维持和终止通信，最小传输单位：会话层协议数据单元。SMTP, DNS 传输层传输层：为应用程序之间提供端到端的逻辑通信（”端”指源主机和目的主机），处理数据包的错误等传输问题。TCP, UDP协议，传输层数据单位为段。 网络层网络层：负责点到点（point-to-point）的传输（这里的”点”指主机或路由器）,进行逻辑地址寻址，实现不同网络之间的路径选择，IP 就在网络层。IP, ICMP, ARP, RARP, AKP, UUCP 协议。路由选择最小单位——分组（包）报文。路由器、网关。 数据链路层数据链路层：对物理层传输的比特流封装成帧，对数据进行差错检测。PPP，STP 协议，交 换机、网桥就处在这一层，最小的传输单位——帧。 物理层物理层：在不同设备中传输比特信息，将 0/1 信号与电信号或者光信号互相转化，作用是屏蔽不同的传输媒体和通信手段的差异，使得数据链路层感觉不到这些差异。IEEE 802.2、Ethernet v.2、Internetwork。集线器（hub）、中继器。","categories":[{"name":"计算机网络","slug":"计算机网络","permalink":"https://changzeyan.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"}],"tags":[{"name":"概述","slug":"概述","permalink":"https://changzeyan.github.io/tags/%E6%A6%82%E8%BF%B0/"}],"author":"ChangzeYan"},{"title":"Git命令","slug":"Git/Git命令","date":"2020-12-03T02:51:18.000Z","updated":"2021-01-07T12:54:16.048Z","comments":true,"path":"2020/12/03/git/git-ming-ling/","link":"","permalink":"https://changzeyan.github.io/2020/12/03/git/git-ming-ling/","excerpt":"","text":"关联远程仓库并上传首先在github上创建仓库 git init 将本地项目工作区的所有文件添加到暂存区 git add . # 可选 &amp;#123; git config user.email \"2155513297@qq.com\" git config user.name \"Winds-Y\" &amp;#125; git commit -m \"firstCommit\" (若有修改或添加文件执行) 关联远程仓库：origin 为远程仓库名 git remote add origin https://github.com/Yahtz/TryBmob.git（远程仓库地址） # 多用户： &amp;#123; # git remote add origin git@ChangzeYan:ChangzeYan/test.git # git remote add origin git@Winds-Y:Winds-Y/test.git &amp;#125; git push -u origin master （若远程仓库有readme.md等本地仓库没有的文件，需要先pull） （git pull origin master --allow-unrelated-histories） 或者 （git pull --rebase origin master） 然后再push 查看# 查看添加到git的文件 git ls-files 添加文件不成功git add出现 “fatal: in unpopulated submodule XXX” 错误在本地仓库如果克隆了其他远程仓库，该远程仓库就会git add失败，解决： git rm -rf --cached xxxx(文件夹的名称) git add xxxx/*","categories":[{"name":"Git","slug":"Git","permalink":"https://changzeyan.github.io/categories/Git/"}],"tags":[],"author":"ChangzeYan"},{"title":"Docker安装与配置","slug":"Docker/安装docker","date":"2020-12-02T07:32:43.000Z","updated":"2021-01-27T15:01:14.418Z","comments":true,"path":"2020/12/02/docker/an-zhuang-docker/","link":"","permalink":"https://changzeyan.github.io/2020/12/02/docker/an-zhuang-docker/","excerpt":"","text":"Linux上的安装与配置参考：CentOS7上安装docker 准备Docker 要求 CentOS 系统的内核版本高于 3.10 ，查看本页面的前提条件来验证你的CentOS 版本是否支持 Docker 。1、通过 uname -r 命令查看你当前的内核版本（若不满足要求可以先升级内核） uname -r 2、使用 root 权限登录 Centos。确保 yum 包更新到最新。 $ sudo yum update 3、卸载旧版本的docker(如果安装过旧版本的话) $ sudo yum remove docker docker-common docker-selinux docker-engine 4、安装需要的软件包， yum-util 提供yum-config-manager功能，另外两个是devicemapper驱动依赖的 $ sudo yum install -y yum-utils device-mapper-persistent-data lvm2 5、设置yum源 $ sudo yum-config-manager --add-repo https://download.docker.com/linux/centos/docker-ce.repo 可以查看所有仓库中所有docker版本，并选择特定版本安装 $ yum list docker-ce --showduplicates | sort -r 安装由于repo中默认只开启stable仓库，故这里安装的是最新稳定版 sudo yum install docker-ce 或者安装指定的版本： sudo yum install &lt;FQPN> # 例如：sudo yum install docker-ce-17.12.0.ce 启动启动并加入开机启动 $ sudo systemctl start docker $ sudo systemctl enable docker 验证安装是否成功(有client和service两部分表示docker安装启动都成功了) $ docker version 如果有报错： Transaction check error: file /usr/bin/docker from install of docker-ce-17.12.0.ce-1.el7.centos.x86_64 conflicts with file from package docker-common-2:1.12.6-68.gitec8512b.el7.centos.x86_64 file /usr/bin/docker-containerd from install of docker-ce-17.12.0.ce-1.el7.centos.x86_64 conflicts with file from package docker-common-2:1.12.6-68.gitec8512b.el7.centos.x86_64 file /usr/bin/docker-containerd-shim from install of docker-ce-17.12.0.ce-1.el7.centos.x86_64 conflicts with file from package docker-common-2:1.12.6-68.gitec8512b.el7.centos.x86_64 file /usr/bin/dockerd from install of docker-ce-17.12.0.ce-1.el7.centos.x86_64 conflicts with file from package docker-common-2:1.12.6-68.gitec8512b.el7.centos.x86_64 卸载旧版本的包 $ sudo yum erase docker-common-2:1.12.6-68.gitec8512b.el7.centos.x86_64 再次安装： yum install docker-ce 配置国内镜像进入 /etc/docker sudo tee /etc/docker/daemon.json &lt;&lt;-'EOF' 输入： 网易镜像 &amp;#123; \"registry-mirrors\":[\"http://hub-mirror.c.163.com\",\"https://almtd3fa.mirror.aliyuncs.com\"] &amp;#125; EOF 重启docker sudo systemctl daemon-reload sudo systemctl restart docker 开启远程访问修改Docker配置文件 vi /lib/systemd/system/docker.service 修改ExecStart为： ExecStart=/usr/bin/dockerd --containerd=/run/containerd/containerd.sock 修改daemon.json vi /etc/docker/daemon.json 添加键值对,2375为默认端口,也可以指定为任意端口 \"hosts\": [\"0.0.0.0:2375\",\"unix:///var/run/docker.sock\"] 重启docker systemctl daemon-reload systemctl restart docker 开启远程访问后可以在远程主机操作docker要求：操作和被操作的主机都要安装docker # 查看镜像 docker -H IP:2375 images # 查看运行中的容器 docker -H IP:2375 ps 升级docker卸载docker sudo yum remove $(rpm -qa | grep docker) 下载最新版本docker curl -fsSL https://get.docker.com/ | sh 重启docker sudo systemctl restart docker # centos 7 再次查看docker版本 $ docker -v Docker version 18.09.3, build 774a1f4 windows 安装docker专业版开启Hyper-V功能windows专业版要在打开或关闭windows功能那里开启Hyper-V功能。 下载docker：官网安装后，配置环境变量，将: C:\\\\Program Files\\\\Docker\\\\Docker\\\\resources 添加到path中。 配置国内镜像 配置远程访问参考：Windows开启Docker远程访问 先勾选：开启windows防火墙，在管理员模式下： netsh advfirewall firewall add rule name=\"docker_daemon\" dir=in action=allow protocol=TCP localport=2375","categories":[{"name":"Docker","slug":"Docker","permalink":"https://changzeyan.github.io/categories/Docker/"}],"tags":[],"author":"ChangzeYan"},{"title":"Git ignore 文件","slug":"Git/Git ignore文件","date":"2020-11-30T03:14:45.000Z","updated":"2020-12-02T07:31:49.513Z","comments":true,"path":"2020/11/30/git/git-ignore-wen-jian/","link":"","permalink":"https://changzeyan.github.io/2020/11/30/git/git-ignore-wen-jian/","excerpt":"","text":".gitignore参考：git设置忽略文件和目录 忽略正则忽略*.o文件和 *.a文件： *.[oa] 忽略*.b 和 *.B文件，my.b除外 *.[bB] !my.b 忽略dbg文件和dbg目录 dbg 只忽略dbg目录，不忽略dbg文件 dbg/ .gitignore只能忽略那些原来没有被track的文件，如果某些文件已经被纳入了版本管理中，则修改.gitignore是无效的。 删除github中某个文件夹参考：删除文件夹在github上只能删除文件，删除文件夹的方式如下： 在本地仓库： git rm -r --cached target # 删除target文件夹 git commit -m '删除了target文件夹' # 提交,添加操作说明 git push -u origin master # 将本次更改更新到github项目上去","categories":[{"name":"Git","slug":"Git","permalink":"https://changzeyan.github.io/categories/Git/"}],"tags":[],"author":"ChangzeYan"},{"title":"markdown语法","slug":"write/markdown/markdown语法","date":"2020-11-23T03:15:30.000Z","updated":"2020-12-11T04:42:54.642Z","comments":true,"path":"2020/11/23/write/markdown/markdown-yu-fa/","link":"","permalink":"https://changzeyan.github.io/2020/11/23/write/markdown/markdown-yu-fa/","excerpt":"","text":"代码块的语言 Shell bash,shell C# c-sharp,csharp CSS css SASS&amp;SCSS sass,scss Erlang erl,erlang Java java JavaScript js,jscript,javascript PHP php Python py,python Ruby ruby,rails,rb Scala scala SQL sql VisualBasic vb,vbnet XML xml,xhtml Swift swift GO go,golang 将网页上的表格转换成md、latex等的工具：TableConvert 列表无序列表使用星号(*)、加号(+)或是减号(-)作为列表标记，这些标记后面要添加一个空格，然后再填写内容。 有序列表使用数字加.加空格，如： 1. 第一项 2. 第二项 3. 第三项 第一项 第二项 第三项 列表嵌套在子列表中的选项前面添加四个空格即可： 1. 第一项： - 第一项嵌套的第一个元素 - 第一项嵌套的第二个元素 2. 第二项： - 第二项嵌套的第一个元素 - 第二项嵌套的第二个元素 第一项： 第一项嵌套的第一个元素 第一项嵌套的第二个元素 第二项： 第二项嵌套的第一个元素 第二项嵌套的第二个元素 段落缩进第一种：半方大的空白&amp;ensp;或&amp;#8194; 全方大的空白&amp;emsp;或&amp;#8195; 不断行的空白格&amp;nbsp;或&amp;#160; 第二种：markdown语法支持html语法所以可以用这个，本人倾向这种方式，看起来比较干净。 &lt;p style=\"text-indent:2em\">xxxx&lt;/p>","categories":[{"name":"Markdown","slug":"Markdown","permalink":"https://changzeyan.github.io/categories/Markdown/"}],"tags":[{"name":"语法","slug":"语法","permalink":"https://changzeyan.github.io/tags/%E8%AF%AD%E6%B3%95/"}],"author":"ChangzeYan"},{"title":"工作流","slug":"others/activiti/工作流-activiti","date":"2020-11-10T06:22:22.000Z","updated":"2021-01-01T13:06:02.990Z","comments":true,"path":"2020/11/10/others/activiti/gong-zuo-liu-activiti/","link":"","permalink":"https://changzeyan.github.io/2020/11/10/others/activiti/gong-zuo-liu-activiti/","excerpt":"","text":"工作流-Activitibpmn插件 activiti6.0的绘图编辑器操作、使用、汉化 vscode 插件：bpmn editor Springboot 依赖&lt;dependency> &lt;groupId>org.activiti&lt;/groupId> &lt;artifactId>activiti-spring-boot-starter&lt;/artifactId> &lt;version>7.1.0.M4&lt;/version> &lt;/dependency> &lt;dependency> &lt;groupId>org.activiti.dependencies&lt;/groupId> &lt;artifactId>activiti-dependencies&lt;/artifactId> &lt;version>7.1.0.M4&lt;/version> &lt;type>pom&lt;/type> &lt;/dependency> &lt;dependency> &lt;groupId>org.springframework.boot&lt;/groupId> &lt;artifactId>spring-boot-starter-data-jdbc&lt;/artifactId> &lt;/dependency> &lt;dependency> &lt;groupId>org.springframework.boot&lt;/groupId> &lt;artifactId>spring-boot-starter-jdbc&lt;/artifactId> &lt;/dependency> &lt;dependency> &lt;groupId>mysql&lt;/groupId> &lt;artifactId>mysql-connector-java&lt;/artifactId> &lt;scope>runtime&lt;/scope> &lt;/dependency> 配置数据库连接 spring.datasource.driver-class-name=com.mysql.cj.jdbc.Driver spring.datasource.url=jdbc:mysql://localhost:3306/db_activiti?useUnicode=true&amp;characterEncoding=utf-8&amp;useSSL=false&amp;serverTimezone=UTC&amp;nullCatalogMeansCurrent=true&amp;allowPublicKeyRetrieval=true spring.datasource.username=root spring.datasource.password=xxxx # spring boot 整合activiti默认关闭历史表，手动开启历史表如下： spring.activiti.history-level=audit spring.activiti.db-history-used=true # 可选 #流程定义bpmn放置路径 spring.activiti.process-definition-location-prefix=classpath:/process/ #项目随着spring启动自动部署 spring.activiti.check-process-definitions=true 改正上述activiti版本创建数据表的bug启动应用创建表后，运行： SET FOREIGN_KEY_CHECKS=0; -- ---------------------------- -- 创建用户表 -- ---------------------------- DROP TABLE IF EXISTS `user`; CREATE TABLE `user` ( `id` bigint(20) NOT NULL AUTO_INCREMENT, `name` varchar(32) DEFAULT NULL COMMENT '姓名', `address` varchar(64) DEFAULT NULL COMMENT '联系地址', `username` varchar(255) CHARACTER SET utf8mb4 COLLATE utf8mb4_bin DEFAULT NULL COMMENT '账号', `password` varchar(255) CHARACTER SET utf8mb4 COLLATE utf8mb4_bin DEFAULT NULL COMMENT '密码', `roles` varchar(255) CHARACTER SET utf8mb4 COLLATE utf8mb4_bin DEFAULT NULL COMMENT '角色', PRIMARY KEY (`id`) ) ENGINE=InnoDB AUTO_INCREMENT=5 DEFAULT CHARSET=utf8; -- ---------------------------- -- 填充用户表 -- ---------------------------- INSERT INTO `user` VALUES ('1', 'admincn', 'beijing', 'admin', '$2a$10$gw46pmsOVYO.smHYQ2jH.OoXoe.lGP8OStDkHNs/E74GqZDL5K7ki', 'ROLE_ACTIVITI_ADMIN'); INSERT INTO `user` VALUES ('2', 'bajiecn', 'shanghang', 'bajie', '$2a$10$gw46pmsOVYO.smHYQ2jH.OoXoe.lGP8OStDkHNs/E74GqZDL5K7ki', 'ROLE_ACTIVITI_USER,GROUP_activitiTeam,g_bajiewukong'); INSERT INTO `user` VALUES ('3', 'wukongcn', 'beijing', 'wukong', '$2a$10$gw46pmsOVYO.smHYQ2jH.OoXoe.lGP8OStDkHNs/E74GqZDL5K7ki', 'ROLE_ACTIVITI_USER,GROUP_activitiTeam'); INSERT INTO `user` VALUES ('4', 'salaboycn', 'beijing', 'salaboy', '$2a$10$gw46pmsOVYO.smHYQ2jH.OoXoe.lGP8OStDkHNs/E74GqZDL5K7ki', 'ROLE_ACTIVITI_USER,GROUP_activitiTeam'); -- ---------------------------- -- 修复Activiti7的M4版本缺失字段Bug -- ---------------------------- alter table ACT_RE_DEPLOYMENT add column PROJECT_RELEASE_VERSION_ varchar(255) DEFAULT NULL; alter table ACT_RE_DEPLOYMENT add column VERSION_ varchar(255) DEFAULT NULL; -- ---------------------------- -- 动态表单数据存储 -- ---------------------------- DROP TABLE IF EXISTS `formdata`; CREATE TABLE `formdata` ( `PROC_DEF_ID_` varchar(64) DEFAULT NULL, `PROC_INST_ID_` varchar(64) CHARACTER SET utf8 COLLATE utf8_general_ci DEFAULT NULL, `FORM_KEY_` varchar(255) DEFAULT NULL, `Control_ID_` varchar(100) DEFAULT NULL, `Control_VALUE_` varchar(2000) DEFAULT NULL ) ENGINE=InnoDB DEFAULT CHARSET=utf8; spring securityspring-activiti自动集成了spring boot security，访问应用的用户名是：user，启动时会在控制台生成密码： 2020-12-26 20:59:29.582 INFO 11832 --- [ main] .s.s.UserDetailsServiceAutoConfiguration : Using generated security password: b241ae9b-ba60-44a9-8c0d-b5ca45349ed6 去掉密码：在启动类前加注解： @SpringBootApplication(exclude = &amp;#123;org.springframework.boot.autoconfigure.security.servlet.SecurityAutoConfiguration.class, org.springframework.boot.actuate.autoconfigure.security.servlet.ManagementWebSecurityAutoConfiguration.class&amp;#125;) public class ActivitiSpringbootDemoApplication &amp;#123; public static void main(String[] args) &amp;#123; SpringApplication.run(ActivitiSpringbootDemoApplication.class, args); &amp;#125; &amp;#125; 部署和执行 部署的bpmn文件一定要是bpmn格式的文件，不能是xml格式的 部署流程会影响的表：act_re_deployment、act_re_procdef、act_ge_bytearray，如果其中任意一个表中没有写入，则没有部署成功。 @Service public class EnterpriseRaService &amp;#123; @Autowired private RepositoryService repositoryService; @Autowired private RuntimeService runtimeService; // 部署流程： public String deploy()&amp;#123; Deployment deployment=repositoryService.createDeployment() .addClasspathResource(\"processes/analyse1.bpmn\") .name(\"请假流程\") .deploy(); return deployment.getId(); &amp;#125; // 执行流程 public String startProcess()&amp;#123; ProcessInstance instance=runtimeService.startProcessInstanceByKey(\"process_analyse\"); return instance.getId(); &amp;#125; &amp;#125; Service Task参考：自动服务任务服务任务service task需要在bpmn文件中配置与之关联的执行类，类名要写全名，即package.类名，async设置为true表示startProcessInstanceByKey方法立即返回，然后异步执行service task； &lt;bpmn2:serviceTask id=\"Activity_0z1g1ix\" name=\"crawl\" activiti:async=\"true\" activiti:class=\"com.example.cloudactiviti.listener.CrawlListener\"> 与之关联的类实现JavaDelegate接口： package com.example.cloudactiviti.listener; import org.activiti.engine.delegate.DelegateExecution; import org.activiti.engine.delegate.JavaDelegate; import org.springframework.stereotype.Component; @Component public class CrawlListener implements JavaDelegate &amp;#123; @Component public class CrawlListener implements JavaDelegate &amp;#123; @Override public void execute(DelegateExecution delegateExecution) &amp;#123; System.out.println(\"----------------------\"); System.out.println(\"-----模拟事务-------\"); try &amp;#123; for (int i = 0; i &lt; 10; i++) &amp;#123; System.out.println(i); Thread.sleep(1000); &amp;#125; &amp;#125; catch (InterruptedException e) &amp;#123; e.printStackTrace(); &amp;#125; System.out.println(\"end\"); &amp;#125; &amp;#125; &amp;#125; 然后调用startProcessInstanceByKey执行流程，该方法立即返回，流程异步执行。 查询当前流程实例已完成任务其实是查询act_hi_actinst表，按照时间排序，返回最后完成的活动。 public String getLastFinishedTask(String instanceId)&amp;#123; List&lt;HistoricActivityInstance> list=historyService.createHistoricActivityInstanceQuery() .processInstanceId(instanceId).finished().orderByHistoricActivityInstanceStartTime().desc().list(); String lastFinishedTask = \"空任务\"; if(list!=null &amp;&amp; list.size()>0)&amp;#123; lastFinishedTask=list.get(0).getActivityName(); for(HistoricActivityInstance taskInstance:list)&amp;#123; System.out.println(\"已完成：\"+taskInstance.getActivityName()); &amp;#125; &amp;#125;else&amp;#123; System.out.println(\"---------------当前任务为空-------------------\"); &amp;#125; return lastFinishedTask; &amp;#125; 查询正在执行的任务节点idpublic String getCurrentTask(String instanceId)&amp;#123; List&lt;Execution> executionList=runtimeService.createExecutionQuery().processInstanceId(instanceId) .list(); String currentTask=\"已结束\"; if(executionList==null || executionList.size()&lt;1)&amp;#123; return currentTask; &amp;#125;else&amp;#123; Execution execution=executionList.get(1); // 获取正在执行的活动id currentTask=execution.getActivityId(); if(currentTask.equals(\"Activity_0z1g1ix\"))&amp;#123; currentTask=\"crawl\"; &amp;#125;else if(currentTask.equals(\"Activity_1rgp0z1\"))&amp;#123; currentTask=\"analyse\"; &amp;#125; &amp;#125; return currentTask; &amp;#125; 参数的设置和获取在启动Activiti流程实例的时候，设置参数字典： public String startProcess(String a,String b)&amp;#123; Map&lt;String,Object> mapVariables = new HashMap&lt;>(); mapVariables.put(\"strA\",a); mapVariables.put(\"strB\",b); ProcessInstance instance= runtimeService.startProcessInstanceByKey(\"process_analyse\",mapVariables); return instance.getId(); &amp;#125; 然后就可以在JavaDelegate类中获取参数： @Component public class CrawlListener implements JavaDelegate &amp;#123; public void execute(DelegateExecution delegateExecution) &amp;#123; String taskId = delegateExecution.getVariable(\"strA\",String.class); String userId = delegateExecution.getVariable(\"strB\",String.class); &amp;#125; &amp;#125; 监听类中注入bean实现JavaDelegate的service task监听类中，采用Autowired注入bean为null，需要BeanFactoryPostProcessor获取。 import org.springframework.aop.framework.AopContext; import org.springframework.beans.BeansException; import org.springframework.beans.factory.NoSuchBeanDefinitionException; import org.springframework.beans.factory.config.BeanFactoryPostProcessor; import org.springframework.beans.factory.config.ConfigurableListableBeanFactory; import org.springframework.stereotype.Component; /** * spring工具类 方便在非spring管理环境中获取bean * * @author aaa */ @Component public final class SpringUtils implements BeanFactoryPostProcessor &amp;#123; /** Spring应用上下文环境 */ private static ConfigurableListableBeanFactory beanFactory; @Override public void postProcessBeanFactory(ConfigurableListableBeanFactory beanFactory) throws BeansException &amp;#123; SpringUtils.beanFactory = beanFactory; &amp;#125; /** * 获取对象 * * @param name * @return Object 一个以所给名字注册的bean的实例 * @throws org.springframework.beans.BeansException * */ @SuppressWarnings(\"unchecked\") public static &lt;T> T getBean(String name) throws BeansException &amp;#123; return (T) beanFactory.getBean(name); &amp;#125; /** * 获取类型为requiredType的对象 * * @param clz * @return * @throws org.springframework.beans.BeansException * */ public static &lt;T> T getBean(Class&lt;T> clz) throws BeansException &amp;#123; T result = (T) beanFactory.getBean(clz); return result; &amp;#125; /** * 如果BeanFactory包含一个与所给名称匹配的bean定义，则返回true * * @param name * @return boolean */ public static boolean containsBean(String name) &amp;#123; return beanFactory.containsBean(name); &amp;#125; /** * 判断以给定名字注册的bean定义是一个singleton还是一个prototype。 如果与给定名字相应的bean定义没有被找到，将会抛出一个异常（NoSuchBeanDefinitionException） * * @param name * @return boolean * @throws org.springframework.beans.factory.NoSuchBeanDefinitionException * */ public static boolean isSingleton(String name) throws NoSuchBeanDefinitionException &amp;#123; return beanFactory.isSingleton(name); &amp;#125; /** * @param name * @return Class 注册对象的类型 * @throws org.springframework.beans.factory.NoSuchBeanDefinitionException * */ public static Class&lt;?> getType(String name) throws NoSuchBeanDefinitionException &amp;#123; return beanFactory.getType(name); &amp;#125; /** * 如果给定的bean名字在bean定义中有别名，则返回这些别名 * * @param name * @return * @throws org.springframework.beans.factory.NoSuchBeanDefinitionException * */ public static String[] getAliases(String name) throws NoSuchBeanDefinitionException &amp;#123; return beanFactory.getAliases(name); &amp;#125; /** * 获取aop代理对象 * * @param invoker * @return */ @SuppressWarnings(\"unchecked\") public static &lt;T> T getAopProxy(T invoker) &amp;#123; return (T) AopContext.currentProxy(); &amp;#125; &amp;#125; 然后用SpringUtils.getBean(注入类.class)获取。 IActivitiGraph activitiGraph=SpringUtils.getBean(IActivitiGraph.class); 代替 @Autowired IActivitiGraph activitiGraph;","categories":[{"name":"工作流","slug":"工作流","permalink":"https://changzeyan.github.io/categories/%E5%B7%A5%E4%BD%9C%E6%B5%81/"}],"tags":[{"name":"activiti","slug":"activiti","permalink":"https://changzeyan.github.io/tags/activiti/"}],"author":"ChangzeYan"},{"title":"KMP","slug":"leetcode/string/KMP","date":"2019-08-26T08:49:56.000Z","updated":"2020-12-02T12:26:54.386Z","comments":true,"path":"2019/08/26/leetcode/string/kmp/","link":"","permalink":"https://changzeyan.github.io/2019/08/26/leetcode/string/kmp/","excerpt":"","text":"KMPNext数组的含义记录当前字符前缀字符串的最长前缀后缀的长度，记录了模式串在当前位置失配后，模式串指针j指向的下一个位置，即最大相同前缀的下一个字符 Next数组降低时间复杂度的原理参考： Kmp中next数组含义 从头到尾彻底理解KMP ...ABCDABCX --> 目标串S ABCDABCY --> 模式串P 此时，模式串到达字符Y处失配，证明模式串中Y之前的字符都已匹配成功，注意到，前缀字符串ABCDABC的共同最长前后缀为ABC，此时，目标串的前缀ABC和模式串的前缀ABC对应，目标串的后缀ABC和模式串的后缀ABC对应，失配后，模式串的指针跳到D处 ...ABCDABCX --> 目标串S ABCDABCY --> 模式串P 此时, 模式串中D 之前的字符 ABC 仍是匹配的，因为，此时目标串的后缀 ABC 和 模式串的前缀 ABC 相匹配。 Next数组的求解方法方法1根据字符串的首尾相同最长子串 方法2对模式串的标号方式不同，求出的next数组也不相同。模式串如果从0开始标号，求出的next数组比从1标号的next数组每位小1。 从1开始标号：前两位固定为0、1 标号 1 2 3 4 5 6 7 8 9 10 11 12 P a b a b a a a b a b a a Next 0 1 1 2 3 4 2 2 3 4 5 6 字符串的前后定义：标号小的为前面 求第3位a的next值，看它前一位字符，为b(后面一直和b比较，b为目标字符),其next值为1 ——&gt; 找标号为1的字符，为a，不等于b，但是找到第1位了，则将第3位的next置1 求第4位的next值，看第3位的字符，为a(后面一直和a比较，a为目标字符),其next值为1 –&gt; 找标号为1的字符，为a，等于a，以第3位上的next值作为标号的字符等于a，所以，第3位 next值加1，作为目标位(第4位)的next值 求第5位的next值，看第4位的字符，为b(后面一直和b比较，b为目标字符)，其next值为2 –&gt; 找标号为2的字符，为b，等于b，以第4位上的next值作为标号的字符等于b，所以，第4位 next值加1，作为目标位(第5位)的next值 求第6位的next值，看第5位的字符，为a(后面一直和a比较，a为目标字符)，其next值为3 –&gt; 找标号为3的字符，为a，等于a，以第5位上的next值作为标号的字符等于a，所以，第5位 next值加1，作为目标位(第5位)的next值 求第7位的next值，看第6位的字符，为a(后面一直和a比较，a为目标字符)，其next值为4 –&gt; 找标号为4的字符，为b，不等于a，继续寻找–&gt; 标号为4的next值为 2 –&gt; 标号为 2 的字符为b，不等于a，继续寻找 –&gt; 标号 2 的next值为 1 –&gt; 标号为 1 的字符为 a，等于a， 以第2位上的next值作为标号的字符等于a，所以，第2位 next值加1，作为目标位(第7位)的next值 求第8位的next值，看第7位的字符，为a(后面一直和a比较，a为目标字符)，其next为 2，–&gt; 标号为 2 的字符为b，不等于a， 继续寻找，标号 2 的next值为 1 –&gt; 标号为 1 的字符为 a，等于a，以第2位上的next值作为标号的字符等于a，所以，第2位 next值加1，作为目标位(第8位)的next值 求第9位的next值，看第8位的字符，为b(后面一直和b比较，b为目标字符)，其next值为2 –&gt; 找标号为2的字符，为b，等于b，以第8位上的next值作为标号的字符等于b，所以，第8位 next值加1，作为目标位(第9位)的next值 求第9位的next值，看第8位的字符，为b(后面一直和b比较，b为目标字符)，其next值为2 –&gt; 找标号为2的字符，为b，等于b，以第8位上的next值作为标号的字符等于b，所以，第8位 next值加1，作为目标位(第9位)的next值 求第10位的next值，看第9位的字符,为a(后面一直和a比较，a为目标字符),其next值为 3 –&gt; 找标号为3的字符，为a，等于a，以第9位上的next值作为标号的字符等于a，所以，第9位 next值加1，作为目标位(第10位)的next值 求第11位的next值，看第10位的字符，为b(后面一直和b比较，b为目标字符)，其next值为4 –&gt; 找标号为4的字符，为b，等于b，以第10位上的next值作为标号的字符等于b，所以，第10位 next值加1，作为目标位(第11位)的next值 求第12位的next值，看第11位的字符,为a(后面一直和a比较，a为目标字符),其next值为 5 –&gt; 找标号为5的字符，为a，等于a，以第11位上的next值作为标号的字符等于a，所以，第11位 next值加1，作为目标位(第12位)的next值 从0开始标号：前两位固定为-1、0与上面的步骤相同，只是模式串的下标不同： 标号 0 1 2 3 4 5 6 7 8 9 10 11 P a b a b a a a b a b a a Next -1 0 0 1 2 3 1 1 2 3 4 5 Next数组求解根据方法2求next数组的代码如下： def get_next(str_p): next_list = [-1] # j为模式串下标，k为next值 j, k = 0, -1 # next_list 初始化时已经添加了一个-1，所以 判断条件小于 len(str_p)-1 while j &lt; len(str_p) - 1: # k==-1 是判断找没找到第一个字符，j一直是当前字符的前一个字符下标 # str_p[j] == str_p[k] 判断 以某个字符的next值为标号的对应的字符与当前位前一位字符是否相同 if k == -1 or str_p[j] == str_p[k]: # 如果相同，该位next+1作为目标位的next值 k += 1 j += 1 next_list.append(k) else: k = next_list[k] # print(next_list) return next_list KMPdef kmp(s, p): next_list = get_next(p) i, j = 0, 0 while i &lt; len(s) and j &lt; len(p): if j == -1 or s[i] == p[j]: i += 1 j += 1 # 如果失配，目标串指针i不动，模式串指针j跳到失配位的next值处 # 使得失配位置前缀字符串的后缀对应于模式串的前缀 else: j = next_list[j] if j == len(p): return i - j else: return -1 Kmp算法的时间复杂度参考：KMP时间复杂度分析 O(m+n) https://blog.csdn.net/iamyvette/article/details/77433991 https://blog.csdn.net/weixin_38332967/article/details/81944353 https://blog.csdn.net/v_july_v/article/details/7041827","categories":[{"name":"Leetcode","slug":"Leetcode","permalink":"https://changzeyan.github.io/categories/Leetcode/"}],"tags":[{"name":"leetcode","slug":"leetcode","permalink":"https://changzeyan.github.io/tags/leetcode/"},{"name":"string","slug":"string","permalink":"https://changzeyan.github.io/tags/string/"}],"author":"ChangzeYan"},{"title":"两数之和","slug":"leetcode/simple_without_algorithm/两数之和","date":"2019-07-19T07:01:42.000Z","updated":"2020-12-02T12:26:08.337Z","comments":true,"path":"2019/07/19/leetcode/simple-without-algorithm/liang-shu-zhi-he/","link":"","permalink":"https://changzeyan.github.io/2019/07/19/leetcode/simple-without-algorithm/liang-shu-zhi-he/","excerpt":"","text":"两数之和题目地址：两数之和 题目描述给定一个整数数组 nums 和一个目标值 target，请你在该数组中找出和为目标值的那 两个 整数，并返回他们的数组下标。 你可以假设每种输入只会对应一个答案。但是，你不能重复利用这个数组中同样的元素。 示例: 给定 nums = [2, 7, 11, 15], target = 9 因为 nums[0] + nums[1] = 2 + 7 = 9 所以返回 [0, 1] 思路本题不适合使用双指针法，排序后会将原来序号打乱。用一个字典保存数值和其序号之间的对应关系，字典的健是数组的数值，字典的值是该数值的序号。遍历数组，看target-nums[i]在不在字典中，同时保证当前序号和target-nums[i]在字典中对应的值不同，（防止重复使用该数） 代码def twoSum(nums, target): index_value_dic = &amp;#123;&amp;#125; for i in range(len(nums)): need = target - nums[i] # i!=index_value_dic[need] 为了防止[3,3]的情况 if need in index_value_dic and i != index_value_dic[need]: return [i, index_value_dic[need]] else: # 将元素值和其index写入，元素当作健，index为值，可能有重复的元素值例如 nums=[3,3],后一个元素会覆盖前面的键值对 index_value_dic[nums[i]] = i","categories":[{"name":"Leetcode","slug":"Leetcode","permalink":"https://changzeyan.github.io/categories/Leetcode/"}],"tags":[{"name":"leetcode","slug":"leetcode","permalink":"https://changzeyan.github.io/tags/leetcode/"},{"name":"simple","slug":"simple","permalink":"https://changzeyan.github.io/tags/simple/"}],"author":"ChangzeYan"},{"title":"最长公共前缀","slug":"leetcode/string/最长公共前缀","date":"2019-06-23T05:59:58.000Z","updated":"2020-12-02T12:26:45.188Z","comments":true,"path":"2019/06/23/leetcode/string/zui-chang-gong-gong-qian-zhui/","link":"","permalink":"https://changzeyan.github.io/2019/06/23/leetcode/string/zui-chang-gong-gong-qian-zhui/","excerpt":"","text":"最长公共前缀题目地址：最长公关前缀 题目描述编写一个函数来查找字符串数组中的最长公共前缀。 如果不存在公共前缀，返回空字符串 “”。 示例 1: 输入: [\"flower\",\"flow\",\"flight\"] 输出: \"fl\" 示例 2: 输入: [\"dog\",\"racecar\",\"car\"] 输出: \"\" 解释: 输入不存在公共前缀。 说明: 所有输入只包含小写字母 a-z 。 python中字符串有大小，例如：a&lt;b&lt;c; flight &lt; flow &lt; flower 思路 $O(n^2)$: 找出最短的字符串，然后看所有字符串相同位置上的字符是否一样 找出最小和最大字符串，最小和最大字符串的最长公共前缀即整个list的最长公共前缀 代码n方复杂度def longestCommonPrefix(strs): if strs: # 按照字符串长度排序 strs.sort(key=lambda i: len(i)) first_str = strs[0] i = 0 flag = True while i &lt; len(first_str) and flag: s = first_str[i] for st in strs: if st[i] != s: flag = False if flag: i += 1 print(first_str[0:i]) return first_str[0:i] else: return \"\" n复杂度def longestCommonPrefix2(strs): if not strs: return \"\" # 按字母表顺序：flight &lt; flow &lt;flower min_str = min(strs) max_str = max(strs) # 只需要找最小和最大字符串的最长公共前缀 for i, x in enumerate(min_str): if x != max_str[i]: return min_str[:i] return min_str","categories":[{"name":"Leetcode","slug":"Leetcode","permalink":"https://changzeyan.github.io/categories/Leetcode/"}],"tags":[{"name":"leetcode","slug":"leetcode","permalink":"https://changzeyan.github.io/tags/leetcode/"},{"name":"string","slug":"string","permalink":"https://changzeyan.github.io/tags/string/"}],"author":"ChangzeYan"},{"title":"罗马数字转整数","slug":"leetcode/simple_without_algorithm/罗马数字转整数","date":"2019-06-22T09:11:34.000Z","updated":"2020-12-02T12:26:06.066Z","comments":true,"path":"2019/06/22/leetcode/simple-without-algorithm/luo-ma-shu-zi-zhuan-zheng-shu/","link":"","permalink":"https://changzeyan.github.io/2019/06/22/leetcode/simple-without-algorithm/luo-ma-shu-zi-zhuan-zheng-shu/","excerpt":"","text":"罗马数字转整数题目地址：罗马数字转整数 题目描述罗马数字包含以下七种字符: I， V， X， L，C，D 和 M。 字符 数值 I 1 V 5 X 10 L 50 C 100 D 500 M 1000 例如， 罗马数字 2 写做 II ，即为两个并列的 1。12 写做 XII ，即为 X + II 。 27 写做 XXVII, 即为 XX + V + II 。 通常情况下，罗马数字中小的数字在大的数字的右边。但也存在特例，例如 4 不写做 IIII，而是 IV。数字 1 在数字 5 的左边，所表示的数等于大数 5 减小数 1 得到的数值 4 。同样地，数字 9 表示为 IX。这个特殊的规则只适用于以下六种情况： I 可以放在 V (5) 和 X (10) 的左边，来表示 4 和 9。 X 可以放在 L (50) 和 C (100) 的左边，来表示 40 和 90。 C 可以放在 D (500) 和 M (1000) 的左边，来表示 400 和 900。 给定一个罗马数字，将其转换成整数。输入确保在 1 到 3999 的范围内。 示例 1: 输入: \"III\" 输出: 3 示例 2: 输入: \"IV\" 输出: 4 示例 3: 输入: \"IX\" 输出: 9 示例 4: 输入: \"LVIII\" 输出: 58 解释: L = 50, V= 5, III = 3. 示例 5: 输入: \"MCMXCIV\" 输出: 1994 解释: M = 1000, CM = 900, XC = 90, IV = 4. 思路 暴力条件判断：判断当前位的时候同时判断下一位，共有7种情况，分别以“I， V， X， L，C，D 和 M”开头M-> M C-> CM、CD、C D-> D X-> XC、XL、X L-> L I-> IX、IV、I V-> V 观察罗马数字的结构特点：I &lt; V &lt; X &lt; L &lt; C &lt; D &lt; M 特殊情况： CM = M-C = -C+M = 900 CD = D-C = -C+D = 400 ...... 判断当前字符是否“小于”后一个字符，如果小于，则减去该字符对应的数值；如果大于则加上该字符对应的数值 代码条件判断def romanToInt(s: str) -> int: res = 0 i = 0 # 因为要修改 i 的数值，所以不能用rang() while i &lt; len(s): if s[i] == 'M': res += 1000 elif s[i] == 'C': if i + 1 &lt; len(s) and s[i + 1] == 'M': res += 900 i += 1 elif i + 1 &lt; len(s) and s[i + 1] == 'D': res += 400 i += 1 else: res += 100 elif s[i] == 'D': res += 500 elif s[i] == 'X': if i + 1 &lt; len(s) and s[i + 1] == 'C': res += 90 i += 1 elif i + 1 &lt; len(s) and s[i + 1] == 'L': res += 40 i += 1 else: res += 10 elif s[i] == 'L': res += 50 elif s[i] == 'I': if i + 1 &lt; len(s) and s[i + 1] == 'X': res += 9 i += 1 elif i + 1 &lt; len(s) and s[i + 1] == 'V': res += 4 i += 1 else: res += 1 elif s[i] == 'V': res += 5 i += 1 print(res) return res 根据结构def romanToInt2(s: str) -> int: res = 0 str_num_dic = &amp;#123; 'I': 1, 'V': 5, 'X': 10, 'L': 50, 'C': 100, 'D': 500, 'M': 1000 &amp;#125; for i in range(len(s) - 1): # 如果小于下一个字符就减去，如果大于就加上 res = res - str_num_dic[s[i]] if str_num_dic[s[i]] &lt; str_num_dic[s[i + 1]] else res + str_num_dic[s[i]] return res+str_num_dic[s[-1]]","categories":[{"name":"Leetcode","slug":"Leetcode","permalink":"https://changzeyan.github.io/categories/Leetcode/"}],"tags":[{"name":"leetcode","slug":"leetcode","permalink":"https://changzeyan.github.io/tags/leetcode/"},{"name":"DataStructure","slug":"DataStructure","permalink":"https://changzeyan.github.io/tags/DataStructure/"}],"author":"ChangzeYan"},{"title":"整数转罗马数字","slug":"leetcode/simple_without_algorithm/整数转罗马数字","date":"2019-06-21T07:51:02.000Z","updated":"2020-12-02T12:26:00.507Z","comments":true,"path":"2019/06/21/leetcode/simple-without-algorithm/zheng-shu-zhuan-luo-ma-shu-zi/","link":"","permalink":"https://changzeyan.github.io/2019/06/21/leetcode/simple-without-algorithm/zheng-shu-zhuan-luo-ma-shu-zi/","excerpt":"","text":"整数转罗马数字题目地址：整数转罗马数字 题目描述罗马数字包含以下七种字符： I， V， X， L，C，D 和 M。 字符 数值 I 1 V 5 X 10 L 50 C 100 D 500 M 1000 例如， 罗马数字 2 写做 II ，即为两个并列的 1。12 写做 XII ，即为 X + II 。 27 写做 XXVII, 即为 XX + V + II 。 通常情况下，罗马数字中小的数字在大的数字的右边。但也存在特例，例如 4 不写做 IIII，而是 IV。数字 1 在数字 5 的左边，所表示的数等于大数 5 减小数 1 得到的数值 4 。同样地，数字 9 表示为 IX。这个特殊的规则只适用于以下六种情况： I 可以放在 V (5) 和 X (10) 的左边，来表示 4 和 9。 X 可以放在 L (50) 和 C (100) 的左边，来表示 40 和 90。 C 可以放在 D (500) 和 M (1000) 的左边，来表示 400 和 900。 给定一个整数，将其转为罗马数字。输入确保在 1 到 3999 的范围内。 示例 1: 输入: 3 输出: \"III\" 示例 2: 输入: 4 输出: \"IV\" 示例 3: 输入: 9 输出: \"IX\" 示例 4: 输入: 58 输出: \"LVIII\" 解释: L = 50, V = 5, III = 3. 示例 5: 输入: 1994 输出: \"MCMXCIV\" 解释: M = 1000, CM = 900, XC = 90, IV = 4. 思路 暴力分类讨论：遍历数字的每一位，判断该位是个位、十位、百位还是千位，然后执行相应的转换操作； 采用数字-字符结构的字典存储关键数字（进位有关）与对应字符的映射关系，然后用给定数字对这些关键数字依次取模，取模结果乘以该关键数字对应的字符 代码暴力分类讨论def intToRoman(num: int) -> str: string_1 = '' string_2 = '' string_3 = '' string_4 = '' index = 1 while num: x = num % 10 num //= 10 # 个位 if index == 1: if x == 0: string_1 += '' elif x == 4: string_1 += 'IV' elif x == 9: string_1 += 'IX' elif 1 &lt;= x &lt;= 3: while x: string_1 += 'I' x -= 1 elif 5 &lt;= x &lt;= 8: x -= 5 string_1 += 'V' while x: string_1 += 'I' x -= 1 # 十位 elif index == 2: if x == 0: string_2 += '' elif x == 4: string_2 += 'XL' elif x == 9: string_2 += 'XC' elif 1 &lt;= x &lt;= 3: while x: string_2 += 'X' x -= 1 elif 5 &lt;= x &lt;= 8: x -= 5 string_2 += 'L' while x: string_2 += 'X' x -= 1 # 百位 elif index == 3: if x == 0: string_3 += '' elif x == 4: string_3 += 'CD' elif x == 9: string_3 += 'CM' elif 1 &lt;= x &lt;= 3: while x: string_3 += 'C' x -= 1 elif 5 &lt;= x &lt;= 8: x -= 5 string_3 += 'D' while x: string_3 += 'C' x -= 1 # 千位，只有1，2，3三种情况 if index == 4: while x: string_4 += 'M' x -= 1 index += 1 string = string_4 + string_3 + string_2 + string_1 print(string) return string 优化暴力分类讨论def intToRoman2(num: int) -> str: string = '' index = 1 while num: x = num % 10 if index == 1: string = str_of_num(x, 'I', 'V', 'X') + string elif index == 2: string = str_of_num(x, 'X', 'L', 'C') + string elif index == 3: string = str_of_num(x, 'C', 'D', 'M') + string else: string_4 = '' while x: string_4 += 'M' x -= 1 string = string_4 + string num //= 10 index += 1 print(string) return string # 复用分类讨论代码 def str_of_num(x, a, b, c): string = '' if x == 0: string += '' elif x == 4: string += a + b elif x == 9: string += a + c elif 1 &lt;= x &lt;= 3: while x: string += a x -= 1 elif 5 &lt;= x &lt;= 8: x -= 5 string += b while x: string += a x -= 1 return string 设置映射表，从高位到低位转换def intToRoman3(num: int) -> str: res = '' # 数值和字符映射关系 num_str_dic = &amp;#123; 1000: 'M', 900: 'CM', 500: 'D', 400: 'CD', 100: 'C', 90: 'XC', 50: 'L', 40: 'XL', 10: 'X', 9: 'IX', 5: 'V', 4: 'IV', 1: 'I' &amp;#125; # x 是字典中的健，这里是数字 for x in num_str_dic: # 用num整除 num_str_dic 中的数值，得到的数乘以对应的符号 #（如：2*I=II，如果是0*I，就是\"\"） res += num // x * num_str_dic[x] num %= x return res","categories":[{"name":"Leetcode","slug":"Leetcode","permalink":"https://changzeyan.github.io/categories/Leetcode/"}],"tags":[{"name":"leetcode","slug":"leetcode","permalink":"https://changzeyan.github.io/tags/leetcode/"},{"name":"DataStructure","slug":"DataStructure","permalink":"https://changzeyan.github.io/tags/DataStructure/"}],"author":"ChangzeYan"},{"title":"盛最多水的容器","slug":"leetcode/simple_without_algorithm/盛最多水的容器","date":"2019-06-20T11:43:41.000Z","updated":"2020-12-02T12:26:03.651Z","comments":true,"path":"2019/06/20/leetcode/simple-without-algorithm/sheng-zui-duo-shui-de-rong-qi/","link":"","permalink":"https://changzeyan.github.io/2019/06/20/leetcode/simple-without-algorithm/sheng-zui-duo-shui-de-rong-qi/","excerpt":"","text":"盛最多水的容器题目地址：盛最多水的容器 题目描述给定 n 个非负整数 a1，a2，…，an，每个数代表坐标中的一个点 (i, ai) 。在坐标内画 n 条垂直线，垂直线 i 的两个端点分别为 (i, ai) 和 (i, 0)。找出其中的两条线，使得它们与 x 轴共同构成的容器可以容纳最多的水。 说明：你不能倾斜容器，且 n 的值至少为 2。 图中垂直线代表输入数组 [1,8,6,2,5,4,8,3,7]。在此情况下，容器能够容纳水（表示为蓝色部分）的最大值为 49。 示例: 输入: [1,8,6,2,5,4,8,3,7] 输出: 49 思路双指针法：设置首尾指针，每次让垂直线长度比较小的移动，每移动一次，更新最大面积 代码def maxArea(height: list) -> int: area = 0 length = len(height) # 双指针，分别指向首尾 left, right = 0, length - 1 while left &lt; right: height_left = height[left] height_right = height[right] # 取较短的 height_min = min(height_left, height_right) # 计算面积 tmp_area = height_min * (right - left) # 更新面积 if tmp_area > area: area = tmp_area # 让较短的垂直线移动 if height_left &lt; height_right: left += 1 else: right -= 1 return area","categories":[{"name":"Leetcode","slug":"Leetcode","permalink":"https://changzeyan.github.io/categories/Leetcode/"}],"tags":[{"name":"leetcode","slug":"leetcode","permalink":"https://changzeyan.github.io/tags/leetcode/"},{"name":"DoublePointer","slug":"DoublePointer","permalink":"https://changzeyan.github.io/tags/DoublePointer/"}],"author":"ChangzeYan"},{"title":"KDD-Cup2012-Track2","slug":"paper/kddcup2012-track2","date":"2019-06-20T06:02:44.000Z","updated":"2020-12-02T12:27:17.636Z","comments":true,"path":"2019/06/20/paper/kddcup2012-track2/","link":"","permalink":"https://changzeyan.github.io/2019/06/20/paper/kddcup2012-track2/","excerpt":"","text":"KDD-Cup2012-Track2A Two-Stage Ensemble of Diverse Models for Advertisement Ranking in KDD Cup 2012问题描述一次会话是指用户和搜索引擎的互动，即一次查询操作。会话包括：用户、搜索内容、搜索引擎搜到的广告、搜索引擎呈现给用户的广告、用户点击的广告（0条或者多条）、搜索会话的深度是指：搜索引擎呈现给用户的广告的数量；广告的位置/position（排名、rank）是指该广告在呈现给用户所有广告中的排名，呈现给用户的所有广告都会生成一个短文本，即广告的标题，标题后面紧跟着一个长文本（即：广告的描述）和一个URL（URL通常被缩短以节省屏幕空间）。 训练集测试集中的每行数据都有12个，含义依次如下： Click: 用户（UserID）点击广告（AdID）的次数 Impression: 广告(AdID)呈现给用户（UserID）的次数(每次查询只会呈现一次) DisplayURL: URL总是随着标题和描述出现，在文件中，URL是匿名的哈希值 AdID: 广告id AdvertiserID: 广告商id Depth: 一次会话呈现给用户的广告数量 Position: 广告在返回给用户广告列表的index QueryID: 搜索id，从0开始的整数，是queryid_tokensid.txt的主键 KeywordID: 关键词id，buyingkeyword_tokensid.txt的主键 TitleID: titleid_tokensid.txt的主键 DescriptionID: descriptionid_tokensid.txt的主键 UserID: userid_profile.txt的主键，当无法识别用户时，此字段的值为0。 注：要预测的是 $\\frac{Click}{Impression}$ ，后面二分类的时候，把Click当成正样本集，Impression-Click 当作负样本集 其他附属文件 queryid_tokensid.txt buyingkeywordid_tokensid.txt titleid_tokensid.txt descriptionid_tokensid.txt userid_profile.txt 对于前4个文件，每一行都是 id query|keyword|ad title|ad description的格式,这些数据可能是自然语言，在文件中都用其哈希匿名化。‘userid_profile.txt’的每一行由UserID，Gender和Age组成，由TAB字符分隔。注：并非训练和测试集中的每个UserID都将出现在’userid_profile.txt’中。 每个字段描述如下： Gender: '1' (男) '2'(女) '0'(unknow) Age: '1' for (0, 12], '2' for (12, 18], '3' for (18, 24], '4' for (24, 30], '5' for (30, 40], and '6' for greater than 40. 测试集除了广告的被呈现次数(Impression)和点击次数(Click)，测试集和训练集保持相同的格式，测试数据集的一个子集用于在排行榜上对提交/更新的结果进行排名 需要提交的结果一个文本文件，每一行只有一个字段：广告的点击率，并且按照顺序与所给文件的行一一对应。 标注版论文 参考[1]杨之之.Kaggle[2] - Predict the click through rate (KDD12 trackl2)[EB/OL].https://blog.csdn.net/u011292007/article/details/36886523 2014-07-09/2019-06-20[2]https://www.kaggle.com/c/kddcup2012-track2/overview","categories":[{"name":"Paper","slug":"Paper","permalink":"https://changzeyan.github.io/categories/Paper/"}],"tags":[{"name":"paper","slug":"paper","permalink":"https://changzeyan.github.io/tags/paper/"},{"name":"KDD","slug":"KDD","permalink":"https://changzeyan.github.io/tags/KDD/"}],"author":"ChangzeYan"},{"title":"回文数","slug":"leetcode/string/回文数","date":"2019-06-19T10:57:00.000Z","updated":"2020-12-02T12:26:33.508Z","comments":true,"path":"2019/06/19/leetcode/string/hui-wen-shu/","link":"","permalink":"https://changzeyan.github.io/2019/06/19/leetcode/string/hui-wen-shu/","excerpt":"","text":"回文数题目地址：回文数 题目描述判断一个整数是否是回文数。回文数是指正序（从左向右）和倒序（从右向左）读都是一样的整数。 示例 1: 输入: 121 输出: true 示例 2: 输入: -121 输出: false 解释: 从左向右读, 为 -121 。 从右向左读, 为 121- 。因此它不是一个回文数。 示例 3: 输入: 10 输出: false 解释: 从右向左读, 为 01 。因此它不是一个回文数。 思路 转换成字符串，翻转，看是否和之前字符串相同 转换成字符串，设置首尾指针，看首尾指针指向的字符是否相同 将整数的每一位保存进list，设置首尾指针，看首尾指针是否相同 代码翻转字符串def isPalindrome(x): str_x = str(x) str_x_reverse = str_x[::-1] if str_x == str_x_reverse: return True else: return False 首尾遍历字符串def isPalindrome2(x): str_x = str(x) first, last = 0, len(str_x) - 1 flag = True while first &lt;= last: if str_x[first] == str_x[last]: first += 1 last -= 1 else: flag = False break return flag 首尾遍历listdef isPalindrome3(x): if x &lt; 0: return False num_list = [] flag = True while x: num_list.append(x % 10) x //= 10 first, last = 0, len(num_list) - 1 while first &lt;= last: if num_list[first] == num_list[last]: first += 1 last -= 1 else: flag = False break return flag","categories":[{"name":"Leetcode","slug":"Leetcode","permalink":"https://changzeyan.github.io/categories/Leetcode/"}],"tags":[{"name":"leetcode","slug":"leetcode","permalink":"https://changzeyan.github.io/tags/leetcode/"},{"name":"string","slug":"string","permalink":"https://changzeyan.github.io/tags/string/"},{"name":"simple","slug":"simple","permalink":"https://changzeyan.github.io/tags/simple/"}],"author":"ChangzeYan"},{"title":"字符串转换整数 (atoi)","slug":"leetcode/string/字符串转换整数-atoi","date":"2019-06-18T11:34:38.000Z","updated":"2020-12-02T12:26:41.705Z","comments":true,"path":"2019/06/18/leetcode/string/zi-fu-chuan-zhuan-huan-zheng-shu-atoi/","link":"","permalink":"https://changzeyan.github.io/2019/06/18/leetcode/string/zi-fu-chuan-zhuan-huan-zheng-shu-atoi/","excerpt":"","text":"字符串转换整数 (atoi)题目地址：字符串转换整数 (atoi) 题目描述请你来实现一个 atoi 函数，使其能将字符串转换成整数。 首先，该函数会根据需要丢弃无用的开头空格字符，直到寻找到第一个非空格的字符为止。 当我们寻找到的第一个非空字符为正或者负号时，则将该符号与之后面尽可能多的连续数字组合起来，作为该整数的正负号；假如第一个非空字符是数字，则直接将其与之后连续的数字字符组合起来，形成整数。 该字符串除了有效的整数部分之后也可能会存在多余的字符，这些字符可以被忽略，它们对于函数不应该造成影响。 注意：假如该字符串中的第一个非空格字符不是一个有效整数字符、字符串为空或字符串仅包含空白字符时，则你的函数不需要进行转换。 在任何情况下，若函数不能进行有效的转换时，请返回 0。 说明： 假设我们的环境只能存储 32 位大小的有符号整数，那么其数值范围为 [−231, 231 − 1]。如果数值超过这个范围，qing返回 INT_MAX (231 − 1) 或 INT_MIN (−231) 。 示例 1: 输入: \"42\" 输出: 42 示例 2: 输入: \" -42\" 输出: -42 解释: 第一个非空白字符为 '-', 它是一个负号。 我们尽可能将负号与后面所有连续出现的数字组合起来，最后得到 -42 。 示例 3: 输入: \"4193 with words\" 输出: 4193 解释: 转换截止于数字 '3' ，因为它的下一个字符不为数字。 示例 4: 输入: \"words and 987\" 输出: 0 解释: 第一个非空字符是 'w', 但它不是数字或正、负号。 因此无法执行有效的转换。 示例 5: 输入: \"-91283472332\" 输出: -2147483648 解释: 数字 \"-91283472332\" 超过 32 位有符号整数范围。 因此返回 INT_MIN (−231) 。 思路判断是否为空串，去除前部空格，再判断是否为空串，判断首字符是否为正负号或者数字，如果是,则保留符号，不是直接return 0，寻找数字，转换成整数，判断是否越界 代码def myAtoi(string): if string == '': return 0 # 去除前部空格 i = 0 while i &lt; len(string) and string[i] == ' ': i += 1 string = string[i:] # print(string) # 空白串的情况 if string == '': return 0 if string[0] == '-' or string[0] == '+' or '0' &lt;= string[0] &lt;= '9': j = 1 # 寻找数字 while j &lt; len(string) and '0' &lt;= string[j] &lt;= '9': j += 1 string = string[0:j] num = 0 # 保存正负号 symbol = '' if string[0] == '-' or string[0] == '+': symbol = string[0] string = string[1:] # 转换为整数 for s in string: tmp = int(s) num = num * 10 + tmp # 判断是否越界 if symbol == '-': if num > 2 ** 31: num = 2 ** 31 num = -num else: if num > 2 ** 31 - 1: num = 2 ** 31 - 1 return num else: return 0","categories":[{"name":"Leetcode","slug":"Leetcode","permalink":"https://changzeyan.github.io/categories/Leetcode/"}],"tags":[{"name":"leetcode","slug":"leetcode","permalink":"https://changzeyan.github.io/tags/leetcode/"},{"name":"string","slug":"string","permalink":"https://changzeyan.github.io/tags/string/"}],"author":"ChangzeYan"},{"title":"无重复字符最长子串","slug":"leetcode/string/无重复字符最长子串","date":"2019-06-16T07:43:53.000Z","updated":"2020-12-02T12:26:37.886Z","comments":true,"path":"2019/06/16/leetcode/string/wu-chong-fu-zi-fu-zui-chang-zi-chuan/","link":"","permalink":"https://changzeyan.github.io/2019/06/16/leetcode/string/wu-chong-fu-zi-fu-zui-chang-zi-chuan/","excerpt":"","text":"无重复字符最长子串题目地址：无重复字符最长子串 题目描述给定一个字符串，请你找出其中不含有重复字符的 最长子串 的长度。 示例 1: 输入: \"abcabcbb\" 输出: 3 解释: 因为无重复字符的最长子串是 \"abc\"，所以其长度为 3。 示例 2: 输入: \"bbbbb\" 输出: 1 解释: 因为无重复字符的最长子串是 \"b\"，所以其长度为 1。 示例 3: 输入: \"pwwkew\" 输出: 3 解释: 因为无重复字符的最长子串是 \"wke\"，所以其长度为 3。 请注意，你的答案必须是 子串 的长度，\"pwke\" 是一个子序列，不是子串。 思路遍历字符串每个字符时，计算以该字符结束的不含重复字符子串的起始位置i，用该位置减去起始位置便是以该字符结束的最长不重复子串的长度。选取所有字符的该数值中最大的。 起始位置i的计算方法：设置一个&lt;str,int&gt; 类型的字典st，每遍历一个字符都将其当前位置保存进st。每次遍历一个字符，查看st中有没有该字符，如果有，则证明前面有与当前字符重复的字符，则当前字符的i值设置为前面字符的index+1 以str: abcbc为例： index 0 1 2 3 4 str a b c b c 起始位置 i 0 0 0 2 3 以该字符结束的不重复子串长度即index-i+1 1 2 3 2 2 该字符对应的最长不重复子串 a ab abc cb bc 特殊情况：str: abba,即两个相同字符中间的子串，仍含重复字符,此时，发生重复时，不能将当前字符的i值设置为前面重复字符的index+1，而是max(前一个重复字符的index+1,i),即i的取值是一个非递减序列 index 0 1 2 3 str a b b a 起始位置 i 0 0 2 2,注意这里不能是前一个a的index+1=1,如果是，则以该字符结束的最长不重复子串为：bba，显然有重复字符 以该字符结束的不重复子串长度即index-i+1 1 2 1 2 该字符结束的最长不重复子串 a ab b ba 代码class Solution(object): def lengthOfLongestSubstring(self, s): \"\"\" :type s: str :rtype: int \"\"\" # 保存字符index的字典 st = &amp;#123;&amp;#125; i, ans = 0, 0 for j in range(len(s)): if s[j] in st: # 需要取最大值，应对abba的情况 # i是截至j，以s[j]为最后一个元素的最长不重复子串的起始位置，即索引范围是[i,j]的子串是以元素j为最后一个元素的最长子串。 i = max(st[s[j]]+1, i) # 字符串的长度即为字符串的结束位置j，减去起始位置i，加1 ans = max(ans, j - i + 1) st[s[j]] = j return ans","categories":[{"name":"Leetcode","slug":"Leetcode","permalink":"https://changzeyan.github.io/categories/Leetcode/"}],"tags":[{"name":"leetcode","slug":"leetcode","permalink":"https://changzeyan.github.io/tags/leetcode/"},{"name":"string","slug":"string","permalink":"https://changzeyan.github.io/tags/string/"}],"author":"ChangzeYan"},{"title":"最长回文子串","slug":"leetcode/string/最长回文子串","date":"2019-06-16T05:35:44.000Z","updated":"2020-12-02T12:26:48.807Z","comments":true,"path":"2019/06/16/leetcode/string/zui-chang-hui-wen-zi-chuan/","link":"","permalink":"https://changzeyan.github.io/2019/06/16/leetcode/string/zui-chang-hui-wen-zi-chuan/","excerpt":"","text":"最长回文子串题目地址：最长回文子串 题目描述给定一个字符串 s，找到 s 中最长的回文子串。你可以假设 s 的最大长度为 1000。 示例 1： 输入: \"babad\" 输出: \"bab\" 注意: \"aba\" 也是一个有效答案。 示例 2： 输入: \"cbbd\" 输出: \"bb\" 思路回文串特点：关于中心字符对称（长度为奇数）或者关于中心线对称（长度为偶数） 中心扩散法：遍历每一个字符，同时向左右扩散，判断扩散到的两个字符是否相同，如果相同，继续扩散；如果不同，停止 代码class Solution(object): def longestPalindrome(self, s): \"\"\" :type s: str :rtype: str \"\"\" max_l = 0 res = \"\" for i in range(0, len(s)): #以s[i] 为中心向左右扩散 left, right = i, i while(left >= 0 and right &lt; len(s) and s[left] == s[right]): if max_l &lt; right - left + 1: max_l = right - left + 1 res = s[left:right + 1] left -= 1 right += 1 #以s[i],s[i+1]为中心向左右扩散 left, right = i, i + 1 while(left >= 0 and right &lt; len(s) and s[left] == s[right]): if max_l &lt; right - left + 1: max_l = right - left + 1 res = s[left:right + 1] left -= 1 right += 1 return res","categories":[{"name":"Leetcode","slug":"Leetcode","permalink":"https://changzeyan.github.io/categories/Leetcode/"}],"tags":[{"name":"leetcode","slug":"leetcode","permalink":"https://changzeyan.github.io/tags/leetcode/"},{"name":"string","slug":"string","permalink":"https://changzeyan.github.io/tags/string/"}],"author":"ChangzeYan"},{"title":"两数之和-输入BST","slug":"leetcode/tree/两数之和-输入BST","date":"2019-06-15T13:24:40.000Z","updated":"2020-12-02T12:26:59.419Z","comments":true,"path":"2019/06/15/leetcode/tree/liang-shu-zhi-he-shu-ru-bst/","link":"","permalink":"https://changzeyan.github.io/2019/06/15/leetcode/tree/liang-shu-zhi-he-shu-ru-bst/","excerpt":"","text":"两数之和-输入BST题目地址：两数之和-输入BST structureBST: 二叉搜索树，每个节点的值大于其任意左侧子节点的值，小于其任意右节点的值 题目描述给定一个二叉搜索树和一个目标结果，如果 BST 中存在两个元素且它们的和等于给定的目标结果，则返回 true。 案例 1: 输入: 5 / \\ 3 6 / \\ \\ 2 4 7 Target = 9 输出: True 案例 2: 输入: 5 / \\ 3 6 / \\ \\ 2 4 7 Target = 28 输出: False 思路构建树的中序遍历（BST的中序遍历为递增序列） list，设置两个指针，分别指向 list 的首尾，若首尾指针之和小于 Target ，则首指针后移一位；若首尾指针之和大于 Target ，则尾指针前移一位；若首尾指针之和等于 Target 则做出标记，退出循环。 代码class Solution(object): def __init__(self): self.tree_li = [] # 中序遍历 def ergodic_tree(self, root): if root is not None: self.ergodic_tree(root.left) self.tree_li.append(root.val) self.ergodic_tree(root.right) def findTarget(self, root, k): self.ergodic_tree(root) # 设置首尾指针 i, j = 0, len(self.tree_li) - 1 # 设置是否存在Target标志 flag = False while i &lt; j: sum = self.tree_li[i] + self.tree_li[j] if sum == k: flag = True break elif sum &lt; k: i += 1 else: j -= 1 return flag","categories":[{"name":"Leetcode","slug":"Leetcode","permalink":"https://changzeyan.github.io/categories/Leetcode/"}],"tags":[{"name":"leetcode","slug":"leetcode","permalink":"https://changzeyan.github.io/tags/leetcode/"},{"name":"tree","slug":"tree","permalink":"https://changzeyan.github.io/tags/tree/"}],"author":"ChangzeYan"},{"title":"贝叶斯","slug":"paper/PGM/concept/ConceptBayesianNetwork","date":"2019-06-15T06:45:32.000Z","updated":"2020-12-02T12:27:32.579Z","comments":true,"path":"2019/06/15/paper/pgm/concept/conceptbayesiannetwork/","link":"","permalink":"https://changzeyan.github.io/2019/06/15/paper/pgm/concept/conceptbayesiannetwork/","excerpt":"","text":"贝叶斯朴素贝叶斯分类贝叶斯定理已知某条件下的概率，如何得到两条件交换后的概率，也就是在已知 $P(A|B)$ 的情况下如何求得 $P(B|A)$ 的概率。 $P(A|B)$ 是后验概率（posterior probability），也就是我们常说的条件概率。即在条件 $B$ 下，事件 $A$ 发生的概率。相反 $P(A)$ 或 $P(B)$ 称为先验概率（prior probability）。适用于当很容易直接得出 $P(A|B)$，$P(B|A)$ 则很难直接得出，可由 $P(A|B)$ 计算得到 $P(B|A)$$$P(B|A)=\\frac{P(A|B)P(B)}{P(A)}$$ 贝叶斯网Bayesian Network，采用有向无环图表示网络结构，使用条件概率表CPT来描述联合概率分布。 参考概率图模型之：贝叶斯网络","categories":[{"name":"Paper","slug":"Paper","permalink":"https://changzeyan.github.io/categories/Paper/"}],"tags":[{"name":"paper","slug":"paper","permalink":"https://changzeyan.github.io/tags/paper/"},{"name":"PGM","slug":"PGM","permalink":"https://changzeyan.github.io/tags/PGM/"},{"name":"BN","slug":"BN","permalink":"https://changzeyan.github.io/tags/BN/"}],"author":"ChangzeYan"},{"title":"阅读：基于概率图模型的互联网广告点击率预测","slug":"paper/PGM/基于概率图模型的互联网广告点击率预测","date":"2019-06-14T12:17:42.000Z","updated":"2020-12-02T12:27:25.462Z","comments":true,"path":"2019/06/14/paper/pgm/ji-yu-gai-lu-tu-mo-xing-de-hu-lian-wang-guang-gao-dian-ji-lu-yu-ce/","link":"","permalink":"https://changzeyan.github.io/2019/06/14/paper/pgm/ji-yu-gai-lu-tu-mo-xing-de-hu-lian-wang-guang-gao-dian-ji-lu-yu-ce/","excerpt":"","text":"研究内容利用BN（贝叶斯网）的概率推理算法定量地分析任意用户之间的相似性，从而针对特定的广告，获得没有历史点击记录的用户与存在历史点击记录的用户之间存在的广告搜索行为的相似性，进而预测没有点击记录的用户对广告的 CTR（广告点击率） 构建用户相似模型（用户贝叶斯网 UBN） 用户贝叶斯网近似推理（发现相似用户）和CTR预测（预测未点击用户对广告的点击率） 在数据集 KDD CUP 2012-Track 2 上进行实验（构建用户贝叶斯网、近似推理/发现相似用户、预测CTR） 名词解释CTR: 广告点击率 UBN: 用户贝叶斯网 章节安排 第一节给出构建用户贝叶斯网 UBN 的定义和构建方法 第二节给出 UBN 的近似推理算法和相应的 CTR 预测方法 第三节给出实验结果 构建用户相似模型定义用户和关键词集合 用户集合：$U=\\{U_1,U_2,\\cdots,U_n\\}$ 广告关键词集合：$K=\\{K_1,K_2,\\cdots,K_m\\}$ 搜索行为集合：$B=\\{B_1,B_2,\\cdots,B_n\\}$ 用户集合和搜索行为集合等长，$B$ 中的每一个元素代表一个用户的搜索关键词集合。 搜索行为集合中的每个元素都是一个集合，例如：$B_i=\\{B_{i1},B_{i2},\\cdots,B_{il_i}\\}$，表示用户一次搜索对应的关键词集合，称为搜索行为，$B_{ij} \\in K$。 用户 $U_i$ 的搜索内容为： $C_i=&lt; U_i,M_i &gt;$, $M_i=\\{B_{ij} | j=1,2,\\cdots,l_i \\}$。 注：$M_i$ 中， 原文中写的是 i $ =1,2,\\cdots,l_i $ ,我理解的是这里应该为j。 例1：用户 $U_i$ 的搜索行为集合为 $B_i=\\{B_{i1},B_{i2},B_{i3},B_{i4}\\}$ ，其中 $B_{i1}$ ,$B_{i2}$,$B_{i3}$,$B_{i4}$,对应的关键词分别为：$K_{1}$, $K_{2}$, $K_{3}$, $K_{4}$,则用户 $U_i$ 的搜索内容为 $C_i=&lt; U_i,\\{K_{1},K_{2},K_{3},K_{4} \\} &gt;$ 定义UBN用户贝叶斯网： 节点：每个节点代表一个用户，用户集合 $U=\\{U_1,U_2,\\cdots,U_n\\}$ 即节点集合， 边：有向边集$E$代表用户相似关系。若用户之间有边相连，则代表用户之间存在相似关系。用户相似度用 $sim(U_i,U_j)$ 表示：$$sim(U_i,U_j)=\\frac {N(M_i \\cap M_j)}{N(M_i \\cup M_j)}$$设置相似度阈值 $\\varepsilon$ ,若 $sim(U_i,U_j)&gt;\\varepsilon$, 则用户 $U_i$ 和用户 $U_j$ 之间存在一条无向边。 边的方向：针对任意两个有边相连的节点，计算这两个用户的搜索记录中，相同关键词占各自关键词的比例。用户 $U_i$ 对 $U_j$ 的依赖度用 $D(U_i|U_j)$ 表示，用户 $U_j$ 对 $U_i$ 的依赖度用 $D(U_j|U_i)$ 表示。$$D(U_i|U_j)=\\frac{N(M_i,M_j)}{N(M_j)},D(U_j|U_i)=\\frac{N(M_i,M_j)}{N(M_i)}$$如果 $D(U_i|U_j)&gt;D(U_j|U_i)$,则表示$U_i$对$U_j$兴趣的依赖程度大于$U_j$对$U_i$兴趣的依赖程度。即 $U_j$ 指向 $U_i$，表示 $U_j$ 点击过的广告 $U_i$ 点击的可能性较大。 岳昆, 王朝禄, 朱运磊, 等. 基于概率图模型的互联网广告点击率预测[J]. 华东师范大学学报(自然科学版), 2013(3):15-25. 原文：基于概率图模型的互联网广告点击率预测","categories":[{"name":"Paper","slug":"Paper","permalink":"https://changzeyan.github.io/categories/Paper/"}],"tags":[{"name":"paper","slug":"paper","permalink":"https://changzeyan.github.io/tags/paper/"},{"name":"PGM","slug":"PGM","permalink":"https://changzeyan.github.io/tags/PGM/"}]},{"title":"整数反转","slug":"leetcode/cpp_stl/reverse-integer","date":"2019-06-13T06:54:42.000Z","updated":"2020-12-02T12:27:06.573Z","comments":true,"path":"2019/06/13/leetcode/cpp-stl/reverse-integer/","link":"","permalink":"https://changzeyan.github.io/2019/06/13/leetcode/cpp-stl/reverse-integer/","excerpt":"","text":"整数反转题目地址：整数反转 题目描述：给出一个 32 位的有符号整数，你需要将这个整数中每位上的数字进行反转。 示例1： 输入: 123 输出: 321 示例 2: 输入: -123 输出: -321 示例 3: 输入: 120 输出: 21 注意: 假设我们的环境只能存储得下 32 位的有符号整数，则其数值范围为 [−231, 231 − 1]。请根据这个假设，如果反转后整数溢出那么就返回 0。 cppint 的范围 [-2^31,2^31-1] C中常量INT_MAX和INT_MIN分别表示最大、最小整数，定义在头文件limits.h中。 INT_MAX = 2147483647(2^31-1) INT_MIN = -2147483648(-2^31) 思路利用x%10循环取出原数最后一位，作为reverse_num的首位 long long reverse_num=0; //用long long定义反转后的结果 while (x) &amp;#123; // 不用考虑x的正负，负数的模为负 current=x%10; //每次取出x的最后一位，将其当作反转数的第一位 reverse_num=reverse_num*10+current; &amp;#125; 代码class Solution &amp;#123; public: int reverse(int x) &amp;#123; long long num=0; while(x)&amp;#123; int current_num=x%10; cout&lt;&lt;current_num&lt;&lt;endl; num=num*10+current_num; if(num&lt;INT_MIN ||num>INT_MAX)&amp;#123; return 0; &amp;#125; x/=10; &amp;#125; //cout&lt;&lt;num&lt;&lt;endl; return num; &amp;#125; &amp;#125;;","categories":[{"name":"Leetcode","slug":"Leetcode","permalink":"https://changzeyan.github.io/categories/Leetcode/"}],"tags":[{"name":"leetcode","slug":"leetcode","permalink":"https://changzeyan.github.io/tags/leetcode/"},{"name":"cpp_stl","slug":"cpp-stl","permalink":"https://changzeyan.github.io/tags/cpp-stl/"}]},{"title":"Z字形变换","slug":"leetcode/simple_without_algorithm/zigzag-conversion","date":"2019-06-13T06:54:42.000Z","updated":"2020-12-02T12:26:16.313Z","comments":true,"path":"2019/06/13/leetcode/simple-without-algorithm/zigzag-conversion/","link":"","permalink":"https://changzeyan.github.io/2019/06/13/leetcode/simple-without-algorithm/zigzag-conversion/","excerpt":"","text":"Z字形变换题目地址：Z字形变换 题目描述将一个给定字符串根据给定的行数，以从上往下、从左到右进行 Z 字形排列。比如输入字符串为 “LEETCODEISHIRING” 行数为 3 时，排列如下： L C I R E T O E S I I G E D H N 之后，你的输出需要从左往右逐行读取，产生出一个新的字符串，比如：”LCIRETOESIIGEDHN”。示例 1: 输入: s = &quot;LEETCODEISHIRING&quot;, numRows = 3 输出: &quot;LCIRETOESIIGEDHN&quot; 示例 2: 输入: s = &quot;LEETCODEISHIRING&quot;, numRows = 4 输出: &quot;LDREOEIIECIHNTSG&quot; 解释: L D R E O E I I E C I H N T S G 思路：画出变换后字母的图形，将每个字母的行号写在它右边 L1 C1 I1 R1 E2 T2 O2 E2 S2 I2 I2 G2 E3 D3 H3 N3 将每个字母变换后对应的行号与该字母对应： LEETCODEISHIRING 1232123212321232 便可以得到字母变换后行号的规律 代码// 保存字母与其行号对应关系的结构体 struct Node&amp;#123; int row; char c; &amp;#125;; class Solution &amp;#123; public: string convert(string s, int numRows) &amp;#123; if(s.empty())&amp;#123; return \"\"; &amp;#125; if(numRows==1)&amp;#123; return s; &amp;#125; string result_str; // 初始化行号 int ptr=1; // 决定行号是增加还是减少 bool flag=true; int len=s.length(); Node nodeList[len]; for(int i=0;i&lt;len;i++)&amp;#123; Node n&amp;#123;&amp;#125;; n.c=s[i]; n.row=ptr; if(flag)&amp;#123; ptr++; &amp;#125;else&amp;#123; ptr--; &amp;#125; if(ptr==numRows || ptr==1)&amp;#123; flag=!flag; &amp;#125; nodeList[i]=n; &amp;#125; string z_character[numRows+1]; for(int i=0;i&lt;len;i++)&amp;#123; // cout&lt;&lt;nodeList[i].row&lt;&lt;\" \"&lt;&lt;nodeList[i].c&lt;&lt;endl; char c=nodeList[i].c; int row=nodeList[i].row; z_character[row]+=c; &amp;#125; for(const string&amp; str:z_character)&amp;#123; result_str+=str; &amp;#125; // cout&lt;&lt;result_str&lt;&lt;endl; return result_str; &amp;#125; &amp;#125;;","categories":[{"name":"Leetcode","slug":"Leetcode","permalink":"https://changzeyan.github.io/categories/Leetcode/"}],"tags":[{"name":"simple","slug":"simple","permalink":"https://changzeyan.github.io/tags/simple/"},{"name":"Leetcode","slug":"Leetcode","permalink":"https://changzeyan.github.io/tags/Leetcode/"}]}],"categories":[{"name":"Jsp","slug":"Jsp","permalink":"https://changzeyan.github.io/categories/Jsp/"},{"name":"tomcat","slug":"tomcat","permalink":"https://changzeyan.github.io/categories/tomcat/"},{"name":"文史哲","slug":"文史哲","permalink":"https://changzeyan.github.io/categories/%E6%96%87%E5%8F%B2%E5%93%B2/"},{"name":"Excel","slug":"Excel","permalink":"https://changzeyan.github.io/categories/Excel/"},{"name":"Webdriver","slug":"Webdriver","permalink":"https://changzeyan.github.io/categories/Webdriver/"},{"name":"PS","slug":"PS","permalink":"https://changzeyan.github.io/categories/PS/"},{"name":"SoftwareTest","slug":"SoftwareTest","permalink":"https://changzeyan.github.io/categories/SoftwareTest/"},{"name":"Latex","slug":"Latex","permalink":"https://changzeyan.github.io/categories/Latex/"},{"name":"Python","slug":"Python","permalink":"https://changzeyan.github.io/categories/Python/"},{"name":"Origin","slug":"Origin","permalink":"https://changzeyan.github.io/categories/Origin/"},{"name":"Liunx","slug":"Liunx","permalink":"https://changzeyan.github.io/categories/Liunx/"},{"name":"Linux","slug":"Linux","permalink":"https://changzeyan.github.io/categories/Linux/"},{"name":"Kafka","slug":"Kafka","permalink":"https://changzeyan.github.io/categories/Kafka/"},{"name":"Java","slug":"Java","permalink":"https://changzeyan.github.io/categories/Java/"},{"name":"Docker","slug":"Docker","permalink":"https://changzeyan.github.io/categories/Docker/"},{"name":"Npm","slug":"Npm","permalink":"https://changzeyan.github.io/categories/Npm/"},{"name":"Leetcode","slug":"Leetcode","permalink":"https://changzeyan.github.io/categories/Leetcode/"},{"name":"Graphql","slug":"Graphql","permalink":"https://changzeyan.github.io/categories/Graphql/"},{"name":"Windows","slug":"Windows","permalink":"https://changzeyan.github.io/categories/Windows/"},{"name":"计算机网络","slug":"计算机网络","permalink":"https://changzeyan.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"},{"name":"Git","slug":"Git","permalink":"https://changzeyan.github.io/categories/Git/"},{"name":"Markdown","slug":"Markdown","permalink":"https://changzeyan.github.io/categories/Markdown/"},{"name":"工作流","slug":"工作流","permalink":"https://changzeyan.github.io/categories/%E5%B7%A5%E4%BD%9C%E6%B5%81/"},{"name":"Paper","slug":"Paper","permalink":"https://changzeyan.github.io/categories/Paper/"}],"tags":[{"name":"pandas","slug":"pandas","permalink":"https://changzeyan.github.io/tags/pandas/"},{"name":"Lst","slug":"Lst","permalink":"https://changzeyan.github.io/tags/Lst/"},{"name":"NLP","slug":"NLP","permalink":"https://changzeyan.github.io/tags/NLP/"},{"name":"Pip","slug":"Pip","permalink":"https://changzeyan.github.io/tags/Pip/"},{"name":"String","slug":"String","permalink":"https://changzeyan.github.io/tags/String/"},{"name":"Mongo","slug":"Mongo","permalink":"https://changzeyan.github.io/tags/Mongo/"},{"name":"Install","slug":"Install","permalink":"https://changzeyan.github.io/tags/Install/"},{"name":"Heap","slug":"Heap","permalink":"https://changzeyan.github.io/tags/Heap/"},{"name":"Java-Kafka","slug":"Java-Kafka","permalink":"https://changzeyan.github.io/tags/Java-Kafka/"},{"name":"Latex-table","slug":"Latex-table","permalink":"https://changzeyan.github.io/tags/Latex-table/"},{"name":"Latex-pic","slug":"Latex-pic","permalink":"https://changzeyan.github.io/tags/Latex-pic/"},{"name":"IO","slug":"IO","permalink":"https://changzeyan.github.io/tags/IO/"},{"name":"Latex-字体","slug":"Latex-字体","permalink":"https://changzeyan.github.io/tags/Latex-%E5%AD%97%E4%BD%93/"},{"name":"Kafka","slug":"Kafka","permalink":"https://changzeyan.github.io/tags/Kafka/"},{"name":"镜像","slug":"镜像","permalink":"https://changzeyan.github.io/tags/%E9%95%9C%E5%83%8F/"},{"name":"hexo","slug":"hexo","permalink":"https://changzeyan.github.io/tags/hexo/"},{"name":"Collection","slug":"Collection","permalink":"https://changzeyan.github.io/tags/Collection/"},{"name":"语法","slug":"语法","permalink":"https://changzeyan.github.io/tags/%E8%AF%AD%E6%B3%95/"},{"name":"Tree","slug":"Tree","permalink":"https://changzeyan.github.io/tags/Tree/"},{"name":"Python-Mongo","slug":"Python-Mongo","permalink":"https://changzeyan.github.io/tags/Python-Mongo/"},{"name":"命令","slug":"命令","permalink":"https://changzeyan.github.io/tags/%E5%91%BD%E4%BB%A4/"},{"name":"Flask","slug":"Flask","permalink":"https://changzeyan.github.io/tags/Flask/"},{"name":"Python","slug":"Python","permalink":"https://changzeyan.github.io/tags/Python/"},{"name":"Conda","slug":"Conda","permalink":"https://changzeyan.github.io/tags/Conda/"},{"name":"Hithesis","slug":"Hithesis","permalink":"https://changzeyan.github.io/tags/Hithesis/"},{"name":"部署","slug":"部署","permalink":"https://changzeyan.github.io/tags/%E9%83%A8%E7%BD%B2/"},{"name":"cmd","slug":"cmd","permalink":"https://changzeyan.github.io/tags/cmd/"},{"name":"概述","slug":"概述","permalink":"https://changzeyan.github.io/tags/%E6%A6%82%E8%BF%B0/"},{"name":"activiti","slug":"activiti","permalink":"https://changzeyan.github.io/tags/activiti/"},{"name":"leetcode","slug":"leetcode","permalink":"https://changzeyan.github.io/tags/leetcode/"},{"name":"string","slug":"string","permalink":"https://changzeyan.github.io/tags/string/"},{"name":"simple","slug":"simple","permalink":"https://changzeyan.github.io/tags/simple/"},{"name":"DataStructure","slug":"DataStructure","permalink":"https://changzeyan.github.io/tags/DataStructure/"},{"name":"DoublePointer","slug":"DoublePointer","permalink":"https://changzeyan.github.io/tags/DoublePointer/"},{"name":"paper","slug":"paper","permalink":"https://changzeyan.github.io/tags/paper/"},{"name":"KDD","slug":"KDD","permalink":"https://changzeyan.github.io/tags/KDD/"},{"name":"tree","slug":"tree","permalink":"https://changzeyan.github.io/tags/tree/"},{"name":"PGM","slug":"PGM","permalink":"https://changzeyan.github.io/tags/PGM/"},{"name":"BN","slug":"BN","permalink":"https://changzeyan.github.io/tags/BN/"},{"name":"cpp_stl","slug":"cpp-stl","permalink":"https://changzeyan.github.io/tags/cpp-stl/"},{"name":"Leetcode","slug":"Leetcode","permalink":"https://changzeyan.github.io/tags/Leetcode/"}]}